<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>白话设计模式28讲 on Yipsen Ye</title>
    <link>http://yipsen.github.io/categories/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/</link>
    <description>Recent content in 白话设计模式28讲 on Yipsen Ye</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 22 Dec 2021 01:37:17 +0800</lastBuildDate><atom:link href="http://yipsen.github.io/categories/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>27 谈谈我对项目重构的看法</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/27-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E7%9A%84%E7%9C%8B%E6%B3%95/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:17 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/27-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E7%9A%84%E7%9C%8B%E6%B3%95/</guid>
      <description>什么叫重构 重构有两种解释，一种是作名词的解释，一种是作动词的解释。
 名词：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
动词：使用一系列重构手法，在不改变软件可观察行为的前提下，调整软件的结构。
 重构是软件开发过程中一个重要的事情之一，重构与重写的区别：
 重构：不是对已有代码的全盘否定，而是对不合理的结构进行调整，合理的模块进行改动；利用更好的方式，写出更好，更有维护性代码。 重写：已有的代码非常复杂混乱，难以修改，重构的时间还不如重新写一个来得快；根据需求另立一个项目，完全重写。  为何要重构  车子脏了就得洗，坏了就得修，报废了就得换。
程序也一样，不合需求就得改，难于跟上业务的变更就得重构，实在没法改了就得重写。
 现在的互联网项目已经不再像传统的瀑布模型的项目，有明确的需求。现在项目迭代的速度和需求的变更都非常的迅速。在软件开发的编码之前我们不可能事先了解所有的需求，软件设计肯定会有考虑不周到不全面的地方；而且随着项目需求的不断变更，很有可能原来的代码设计结构已经不能满足当前的需求。这时就需要对软件结构进行重新调整，也就是重构。
一个项目中，团队成员的技术水平参差不齐。有一些工作年限比较低，技术水平比较差的成员写的代码质量比较差，结构比较混乱，这时就需要对这部分代码进行适当的重构，使其具有更高的可重用性。
一个软件运行时间比较长，被多代程序员进行修修补补，使得这个软件的代码非常的臃肿而庞杂，维护成本非常高。因此，也需要对这个软件进行适当的构架，以降低其修改成本。
要进行代码重构的原因，总结一下，常见的原因有以下几种：
 重复的代码太多，没有复用性；难于维护，需要修改时处处都得改。 代码的结构混乱，注释也不清晰；没有人能清楚地理解这段代码的含义。 程序没有拓展性，遇到新的变化，不能灵活的处理。 对象结构强耦合，业务逻辑太复杂，牵一发而动全身，维护时排查问题非常困难。 部分模块性能低，随着用户的增长，已无法满足响应速度的要求。  这些导致代码重构的原因，称为代码的坏味道，我称它为脏乱差，这些脏乱差的代码是怎样形成的呢？大概有以下几种因素：
 上一个写这段代码程序员经验不足、水平太差，或写代码时不够用心。 奇葩的产品经理提出奇葩的需求。 某一个模块业务太复杂，需求变更的次数太多，经手的程序员太多，每个人都在一个看似合适的地方，加一段看似合适的代码，到最后没人能之完完整整地看懂这段代码的含义。  什么时机重构 重构分为两个级别类型：（1）对现有项目进行代码级别的重构；（2）对现有的业务进行软件架构的升级和系统的升级。对于第一种情况，代码的重构应该贯穿于整个软件开发过程中；对于第二种情况，大型的重构最好封闭进行，由专门的（高水平）团队负责，期间不接任何需求；重新设计、开发新的更高可用、高并发的系统，经集成测试通过后，再用新系统逐步替换老的系统。之所以会有这种系统和架构的升级，主要是因为，对于互联网的产品，为适合的其快速发展的需求，不同的用户量级别，需要采用不同的架构。简单的架构：开发简单、迭代速度快；高可用架构：开发成本高，但支持的用户量大，可承载的并发数高。
第二种情况属于软件架构的范畴，这里主要讨论第一种情况，即对项目本身进行代码级别的重构。这个重构应该贯穿于整个软件开发过程始终，不需要单独拿出一块时间进行，只要你闻到代码的坏味道，即可进行。我们可以遵循三次法则来进行重构：事不过三，三则重构，也就是上一篇《[谈谈我对设计原则的思考]》中的 Rule Of Three 原则。
虽然重构可以随时随地的进行，但还需要一些触发点来触发你去做这一件事，这些触发点主要有以下几个：
（1）添加功能时
当添加新功能时，如果发现某段代码改起来特别困难，拓展功能特别不灵活，就要重构这部分代码了，使添加新特性和功能变得更容易。在添加新功能时，只梳理这部分功能相关的代码；一直保持这种习惯，日积月累，我们的代码会越来越干净，开发速度也会越来越快。
（2）修补错误时
在你改 Bug，查找定位问题时，发现自己以前写的代码或者别人的代码设计上有缺陷（如扩展性不灵活），或健壮性考虑的不够周全（如漏掉一些该处理的异常），导致程序频繁出问题，此时就是一个比较好的重构时机。
可能有人会说：道理都懂，但现实是线上问题出来时根本就没那么多时间允许去重构代码。我想说的是：只要不是十万紧急的高危（大部分高危问题测试阶段都测出来）问题，请尽量养成这种习惯。
每遇到一个问题就正面解决这个问题，不要选择绕行（想尽歪招绕开问题），解决前进道路上的一切障碍。这样你对这块代码就更加熟悉，更加自信；下次再遇到类似的问题，你就会再次使用这段代码或参考这段代码。软件开发就是这样，改善某段代码当前看起来会多花一些时间，但从长远来看这些时间肯定是值得的；清除当前障碍多花一小时，能为你将来避免绕路节省好几天。 持续一段时间后，你会发现代码中的坑逐步被填平，欠下的技术债务也会越来越少。
（3）复审代码时
很多公司会有 Code Review 的要求，每个公司 Code Review 的形式可能不太一样；有的采用“结对编程”的方式，两个人一起互审代码；有的是部门领导进行不定期 Code Review；我们公司是在程序上线之前，代码合并申请的时候，由经验丰富、成熟稳重的资深工程师负责审查。Code Review 的好处是能有效地发现一些潜在的问题（所谓当局者谜，旁观者清！程序开发也一样，同时更能发现自己代码的漏洞）；有助于团队成员进行技术的交流和沟通。
在 Code Review 时发现程序的问题，或设计的不足，这又是一个重构的极佳时机，因为 Code Review 时，对方往往能提出一些更的建议或想法。
如何重构代码 上面讲解了什么时候该重构，怎么进行重构，这又是一个重要的问题。下面将介绍一些最常用和实用的重构方法，下面的这些方法针对各种编程语言都实用。</description>
    </item>
    
    <item>
      <title>26 谈谈我对设计原则的思考</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/26-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:16 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/26-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>如果说设计模式是面向对象编程的编程思想，那设计原则就是这些编程思想的指导总纲。SOLID 原则是众多设计原则中威力最大、最广为人知的五大原则，除 SOLID 原则外，还有一些更为简单实用的原则。
SOLID 原则 SOLID 是面向对象设计（OOD）的头五大基本原则的首字母缩写，由俗称「鲍勃大叔」的 Robert C. Martin 在《敏捷软件开发：原则、模式与实践》一书中整理收集而来。这些原则结合在一起能够方便程序员开发易于维护和扩展的软件。这五原则分别是：
 S——单一职责原则 O——开放封闭原则 L——里氏替换原则 I——接口隔离原则 D——依赖倒置原则  单一职责原则（Single Responsibility Principle，SRP） 核心思想：  A class should have only one reason to change.
一个类应该有且仅有一个原因引起它的变更。
 这句话这样说可能不太容易理解，解释一下：类 T 负责两个不同的职责（可以理解为功能）：职责 P1、职责 P2。当由于职责 P1 需求发生改变而需要修改类 T 时，有可能会导致原本运行正常的职责 P2 功能发生故障。这就不符合单一职责原则，这时就应该将类 T 拆分成两个类 T1、T2，使 T1 完成职责 P1 功能，T2 完成职责 P2 功能。这样，当修改类 T1 时，不会使职责 P2 发生故障风险；同理，当修改 T2 时，也不会使职责 P1 发生故障风险。
说人话：  一个类只负责一项功能或一类相似的功能。
 当然这个“一”并不是绝对的，应该理解为一个类只负责尽可能独立的一项功能，尽可能少的职责。就好比一个人，我们的精力、时间都是有限的；如果我们什么事情都做，那什么事情都做不好；而应该集中精力做一件事，才能把事情做好。
案例分析 我们知道动物都能运动，假设都有一个跑的方法。产品经理告诉你只处理陆生哺乳动物，那我们定义一个动物的类。</description>
    </item>
    
    <item>
      <title>25 谈谈我对设计模式的理解</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/25-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:15 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/25-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>众多书籍之下为何还要写这一课程 设计模式可谓是老生常谈的不能再老生常谈了，我曾经思考过很长一段时间要不要去写这系列的文章，因为这一主题的书籍实在太多了，网上免费的资料也非常的多。思考再三，最终决定写它，主要有以下几个原因：
 网上的资料虽然非常多，但就如同你所知：网上资料一大抄！内容极其雷同而且粗浅。 讲设计模式的书籍虽然非常多，但用 Python 来描述的非常的少，有那么几本也是从国外翻译过来的，内容多少会有些变味。 能把抽象难懂的设计模式讲的通俗易懂、妙趣横生的很少。  设计模式玄吗 我觉得它玄，也不玄！
怎么讲呢？《孙子兵法》玄不玄？也玄！因为芸芸众生中能看懂悟透的人很少，能真正灵活应用的人更少！而且战争的成败受众多因素的影响，如天时、地利、人和。但你要问中国历代名将中有哪个不读《孙子兵法》的？几乎没有，如三国的曹操、南宋的岳飞、明代的戚继光，这些人可谓是把兵法用的出神入化了。那两千多年来世界其他国家没看过《孙子兵法》的是怎么打仗的？照样打。没学过兵法的人就不会使用里面的计策吗？当然会用，而且经常用。比如“借刀杀人”，相信这个人们在耍小聪明的时候都用过；“打草惊蛇”这个计策估计连小孩都会用，这样的例子还有很多。只是你不知道古代已经有人把它总结成“战争模式”了。所以说《孙子兵法》其实也不玄。
同样的道理，“设计模式”是一套被反复使用、多数人知晓的、无数工程师实践的代码设计经验的总结。因此它比较抽象，没有一定的编程经验很难读懂，更不能理解其精髓。所以很多人觉得它玄，但真正的架构师和优秀的程序员，几乎没有不看设计模式的。能把设计模式应用的如火纯青的，那就是大神。同样的问题：没有学过设计模式就不会使用设计模式了吗？当然不是！只要你有两年以上的编程经验，像模板模式、单例模式、适配器（Wrapper）模式，这些你肯定用过（那怕你没有看一本设计模式的书），只是你不知道有前人已经总结成书了，所以说设计模式其实也不玄！
网上看到一句话，我还是很赞同这种说法的：
 对于 10w 行以下的代码量的汉子来说，设计模式 = 玄学。
对于 10w ~ 50w 行代码量的汉子来说，设计模式 = 科学。
对于 50w 行以上代码量的汉子来说，设计模式 = 文学。
 如何区分不同的模式 设计模式是对面向对象思想的常见使用场景的模型总结和归纳。设计模式之间的区分，要更多地从我们含义和应用场景去区别，而不应该从他们的类图结构来区分。
看策略模式、状态模式、桥接模式这三种模式的类图几乎是完全一样的（如下图）。从面向的对象的继承、多态、封装的角度来分析，他们是完全一样的。
但他们的实际应用场景却不同、侧重点不同。策略侧重的算法的变更导致执行结果的差异，状态侧重的是对象本身状态的改变而导致行为的变化，而桥接强调的是实现与抽象的分离。
编程思想的三重境界 所以有人说：设计模式这东西很虚！ 要我说，它确实也虚！ 如果它看得见摸得着，那我就没必要讲了。我说过，设计模式是一套被反复使用、多数人知晓的、无数工程师实践的代码设计经验的总结，它是面向对象思想的高度提炼和模板化。既然是思想，能不虚吗？它就想道家里面的“道”的理念，每个人对道的理解是不样的，对道的认知也有不同的境界，而不同的境界对应着不同的修为。
宋代禅宗大师青原行思提出参禅的三重境界：
 参禅之初，看山是山，看水是水；
禅有悟时，看山不是山，看水不是水；
禅中彻悟，看山仍是山，看水仍是水。
 上面讲述的是对禅道的认识的三重不同境界，设计模式既然是一种编程思想，那也会有不同的境界，我这里也概括它为三重境界：
 **一重境界：**依葫芦画瓢。这属于初学阶段，以为设计模式只有书中提到的那几种模式，模式名称也能倒背如流。但真正要用时，还得去翻书，依关类图照般照改。 **二重境界：**灵活运用。这属于中级阶段，对每一种设计模式都非常熟悉，有较深入的思考，而且能够根据实际的业务场景选择合适的模式，并对相应的模式进行恰当的修改以符合实际需求。 三重境界：心中无模式。这算终于阶段，这里说无模式并非他不用设计模式，而是设计模式的理念已经融入他的灵魂和血液，他已经不在乎哪种具体的通用模式了，每一处代码都遵循了设计的原则，能灵活地创造和使用新的模式（可能这种模式他自己也不知道该叫什么名）。这就是所谓的心中无模式却处处是模式。  </description>
    </item>
    
    <item>
      <title>24 深入解读回调机制：把你技能亮出来</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/24-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E6%8A%8A%E4%BD%A0%E6%8A%80%E8%83%BD%E4%BA%AE%E5%87%BA%E6%9D%A5/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:14 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/24-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E6%8A%8A%E4%BD%A0%E6%8A%80%E8%83%BD%E4%BA%AE%E5%87%BA%E6%9D%A5/</guid>
      <description>铁打的公司，流水的员工！职场中经常有新的员工来，也有老的员工走。为迎接新员工的到来，Tony 所在的公司每个月都有一个新人见面会，在见面会上每个新人都要给大家表演一个节目，节目类型不限，内容随意！只要把你的技能都亮出来，把最有趣的一面展示给大家就行。有的人选择唱一首歌，有的人拉一曲 Ukulele，有的人会说一搞笑段子，有的人会表演魔术，还有的人耍起了滑板，真是各种鬼才……
 用程序来模拟生活 职场处处艰辛，但生活充满乐趣！每个人有自己的爱好，每个人也有自己擅长的技能。在新人见面会上把自己最擅长的一面展示出来，是让大家快速记住你的最好方式。下面我们用程序来模拟一下这个场景。
源码示例：
class Employee:&amp;quot;&amp;quot;&amp;quot;公司员工&amp;quot;&amp;quot;&amp;quot;def __init__(self, name):self.__name = namedef doPerformance(self, skill):print(self.__name + &amp;quot;的表演:&amp;quot;, end=&amp;quot;&amp;quot;)skill()def sing():&amp;quot;&amp;quot;&amp;quot;唱歌&amp;quot;&amp;quot;&amp;quot;print(&amp;quot;唱一首歌&amp;quot;)def dling():&amp;quot;&amp;quot;&amp;quot;拉Ukulele&amp;quot;&amp;quot;&amp;quot;print(&amp;quot;拉一曲Ukulele&amp;quot;)def joke():&amp;quot;&amp;quot;&amp;quot;说段子&amp;quot;&amp;quot;&amp;quot;print(&amp;quot;说一搞笑段子&amp;quot;)def performMagicTricks():&amp;quot;&amp;quot;&amp;quot;表演魔术&amp;quot;&amp;quot;&amp;quot;print(&amp;quot;神秘魔术&amp;quot;)def skateboarding():&amp;quot;&amp;quot;&amp;quot;玩滑板&amp;quot;&amp;quot;&amp;quot;print(&amp;quot;酷炫滑板&amp;quot;)测试代码：
def testSkill():helen = Employee(&amp;quot;Helen&amp;quot;)helen.doPerformance(sing)frank = Employee(&amp;quot;Frank&amp;quot;)frank.doPerformance(dling)jacky = Employee(&amp;quot;Jacky&amp;quot;)jacky.doPerformance(joke)chork = Employee(&amp;quot;Chork&amp;quot;)chork.doPerformance(performMagicTricks)Kerry = Employee(&amp;quot;Kerry&amp;quot;)Kerry.doPerformance(skateboarding)输出结果：
Helen的表演:唱一首歌Frank的表演:拉一曲UkuleleJacky的表演:说一搞笑段子Chork的表演:神秘魔术Kerry的表演:酷炫滑板从剧情中思考回调机制 在上面的示例中，每一个新员工都要进行表演，每个人表演自己擅长的技能。因此我们定义了一个 Employee 类，里面有一个 doPerformance 方法，用来进行表演节目；但每个人擅长的技能都不一样，因此我们为每一个上台表演的人定义了一个方法，在调用时传递给 doPerformance。像这样，将一个函数传递给另一个函数的方式叫回调机制。</description>
    </item>
    
    <item>
      <title>23 深入解读对象池技术：共享让生活更便捷</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/23-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%E5%85%B1%E4%BA%AB%E8%AE%A9%E7%94%9F%E6%B4%BB%E6%9B%B4%E4%BE%BF%E6%8D%B7/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:13 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/23-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%E5%85%B1%E4%BA%AB%E8%AE%A9%E7%94%9F%E6%B4%BB%E6%9B%B4%E4%BE%BF%E6%8D%B7/</guid>
      <description>【故事剧情】
 大学的室友兼死党 Sam 首次来杭州，作为东道主的 Tony 自然得悉心招待，不敢怠慢。这不，不仅要陪吃陪喝还得陪玩，哈哈！
第一次来杭州，西湖必然是非去不可的。正值周末，风和日丽，最适合游玩。上午 9 点出发，Tony 和 Sam 打一辆滴滴快车从滨江到西湖的南山路，然后从大华饭店步行到断桥，之后是穿越断桥，漫步白堤，游走孤山岛，就这样一路走走停停，闲聊、拍照，很快就到了中午。中午在岳王庙附近找了一家生煎，简单解决午餐（大餐留着晚上吃）。因为拍照拍的比较多，手机没电了，正好看到店里有共享充电宝，便借了一个给手机充满电，也多休息了一个小时。 下午，他们准备骑行最美西湖路；吃完饭，找了两辆共享自行车，从杨公堤开始骑行，路过太子湾、雷峰塔，然后再到柳浪闻莺。之后就是沿湖步行走到龙翔桥，找了一家最具杭州特色的饭店解决晚餐……
这一路行程他们从共享汽车（滴滴快车）到共享自行车，再到共享充电宝，共享的生活方式已如影随形地渗透到了生活的方方面面。共享，不仅让我们出行更便捷，而且资源更节约！
 用程序来模拟生活 共享经济的飞速发展真的是改变了我们的生活方式，共享自行车、共享雨伞、共享充电宝、共享 KTV 等，共享让我们的生活更便利，你可以不用带充电宝，却可以随时用到它；共享让我们的资源更节约，你可以不用买自行车，但每个人都能骑到自行车（一辆车可以为多个人服务）。我们以共享充电宝为例，用程序来模拟一下它是怎样做到资源节约和共享的。
源码示例：
class PowerBank:&amp;quot;移动电源&amp;quot;def __init__(self, serialNum, electricQuantity):self.__serialNum = serialNumself.__electricQuantity = electricQuantityself.__user = &#39;&#39;def getSerialNum(self):return self.__serialNumdef getElectricQuantity(self):return self.__electricQuantitydef setUser(self, user):self.__user = userdef getUser(self):return self.__userdef showInfo(self):print(&amp;quot;序列号:&amp;quot; + str(self.__serialNum) + &amp;quot; 电量:&amp;quot; + str(self.__electricQuantity) + &amp;quot;% 使用者:&amp;quot; + self.__user)class ObjectPack:&amp;quot;对象的包装类，封装指定的对象(如充电宝)是否被使用中&amp;quot;def __init__(self, obj, inUsing = False):self.</description>
    </item>
    
    <item>
      <title>22 深入解读过滤器模式：制作一杯鲜纯细腻的豆浆</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/22-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%B6%E4%BD%9C%E4%B8%80%E6%9D%AF%E9%B2%9C%E7%BA%AF%E7%BB%86%E8%85%BB%E7%9A%84%E8%B1%86%E6%B5%86/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:12 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/22-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%B6%E4%BD%9C%E4%B8%80%E6%9D%AF%E9%B2%9C%E7%BA%AF%E7%BB%86%E8%85%BB%E7%9A%84%E8%B1%86%E6%B5%86/</guid>
      <description>故事剧情】
 腊八已过，粥已喝，马上就要过年了！别人家的公司现在都是开年会、发现金红包、发 iPone、发平衡车什么的，而 Tony 什么也没有，只能默默地躲在朋友圈的角落里，好在最后一周还算发了一个慰问品——九阳豆浆机。
豆浆机已经有了，怎么制作一杯鲜纯细腻的豆浆呢？Tony 在网上找了一些资料，摸索了半天总算学会了，准备周末买一些大豆，自制早餐！
把浸泡过的大豆放进机器，再加入半壶水，然后选择模式并按下“启动”键，15 分钟后就可以了，但这并没有完，因为还有最关键的一步，那就是往杯子倒豆浆的时候要用过滤网把豆渣过虑掉。这样，一杯美味的阳光早餐就出来了。
 用程序来模拟生活 世间万物，唯有爱与美食不可辜负，吃的健康才能活的出彩。在上面制作豆浆的过程中，豆浆机很重要，但过滤网更关键，因为它直接影响了豆桨的质量。下面我们用程序来模拟一下这关键的步骤。
源码示例：
class FilterScreen:&amp;quot;&amp;quot;&amp;quot;过滤网&amp;quot;&amp;quot;&amp;quot;def doFilter(self, rawMaterials):for material in rawMaterials:if (material == &amp;quot;豆渣&amp;quot;):rawMaterials.remove(material)return rawMaterials测试代码：
def testFilterScreen():rawMaterials = [&amp;quot;豆浆&amp;quot;, &amp;quot;豆渣&amp;quot;]print(&amp;quot;过滤前：&amp;quot;, rawMaterials)filter = FilterScreen()filteredMaterials = filter.doFilter(rawMaterials)print(&amp;quot;过滤后：&amp;quot;, filteredMaterials)输出结果：
过滤前： [&#39;豆浆&#39;, &#39;豆渣&#39;]过滤后： [&#39;豆浆&#39;]从剧情中思考过滤器模式 在上面的示例中，豆浆机中有豆浆和豆渣，往杯子里倒的过程中，用过滤网把豆渣过滤掉才能获得更加鲜嫩细腻的豆浆。过滤网起着一个过滤的作用，在程序中也有一种类似的机制，叫过滤器模式。
过滤器模式  过滤器模式就是将一组对象，根据某种规则，过滤掉一些不符合要求的对象的过程。
 如在互联网上发布信息时敏感词汇的过滤，在 Web 接口的请求与响应时，对请求和响应信息的过滤。过滤器模式的核心思想非常简单：就是把不需要的信息过滤掉，怎么判定哪些是不需要的信息呢？这就需要制定规则。过滤的过程如下图：
举一更加形象的例子，在基建行业中，沙子是最重要的原材料之一，这些沙子很多是从江河中打捞上来的，而打捞上来的不只有沙子，还有小石头和水。若要得到这些颗粒均匀的沙子，就必须把水和石头过滤掉。
与职责模式的联系 在《[生活中的职责模式——我的假条去哪了]》一文中，我们讲了职责模式（也就是责任链模式）。过滤器与责任链的相似之处是处理过程都是一环一环地进行，不同之处在于责任链中责任的传递一般会有一定的顺序，而过滤器通常没有这种顺序，所以过滤器会比责任链还简单。
过滤器模式的模型抽象 一些熟悉 Python 的读者可能会觉得上面示例中的这种写法太麻烦了，Python 本身就自带了 filter() 函数。用下面这段代码就能轻松搞定，结果是一样的，但代码少了好几行：</description>
    </item>
    
    <item>
      <title>21 生活中的设计模式：那些未完待续的设计模式</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/21-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%82%A3%E4%BA%9B%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:11 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/21-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%82%A3%E4%BA%9B%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>随着技术的不断革新与发展，设计模式也一直在发展，有一些模式已不再常用，同时却有一些新的模式在诞生。本课程并未对这 23 种设计模式都进行一一讲解，因为有一些设计模式在现今软件的开发中用的非常少！而有一些却在面向对象中应用的太频繁，以至于我们都不认为它是一种模式。前面已经讲解了 19 种设计模式，下面将对未提及的 4 种设计模式一并进行说明。
抽象工厂 这个模式与工厂方法模式相比，在实际应用项目中使用的相对较少。一谈到工厂模式，大家一定会想到工厂三姐妹：简单工厂模式、工厂方法模式、抽象工厂模式，这一部分的内容在《[生活中的工厂模式——你要拿铁还是摩卡]》一文的 拓展：工厂三姐妹 的部分已经做了较详细的说明，读者可跳转这一课程中进行阅读。
模板模式 这一模式非常简单，以至于我都不觉得它是一个模式。因为只要是在使用面向对象的语言进行开发时，在有意无意之中就已经在使用它了，举一个例子。
Demo 在阅读电子书时，根据每个人的不同阅读习惯，可以设置不同的翻页方式，如左右平滑、仿真翻页等，不同的翻页方式，会给人以不同的展示效果。
根据这一需求，我们用程序来模拟实现一下效果。
from abc import ABCMeta, abstractmethod# 引入ABCMeta和abstractmethod来定义抽象类和抽象方法class ReaderView(metaclass=ABCMeta):&amp;quot;阅读器视图&amp;quot;def __init__(self):self.__curPageNum = 1def getPage(self, pageNum):self.__curPageNum = pageNumreturn &amp;quot;第&amp;quot; + str(pageNum) + &amp;quot;的内容&amp;quot;def prePage(self):content = self.getPage(self.__curPageNum - 1)self.displayPage(content)def nextPage(self):content = self.getPage(self.__curPageNum + 1)self.displayPage(content)@abstractmethoddef displayPage(self, content):&amp;quot;翻页效果&amp;quot;passclass SmoothView(ReaderView):&amp;quot;左右平滑的视图&amp;quot;def displayPage(self, content):print(&amp;quot;左右平滑:&amp;quot; + content)class SimulationView(ReaderView):&amp;quot;仿真翻页的视图&amp;quot;def displayPage(self, content):print(&amp;quot;仿真翻页:&amp;quot; + content)你看，是不是非常简单，因为模板方法模式只是用了面向对象的继承机制。而这种继承方式，在写代码的时候可能在很多地方已经有意无意的就这么使用了。</description>
    </item>
    
    <item>
      <title>20 生活中的设计模式：与经典设计模式的不解渊源</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/20-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E8%A7%A3%E6%B8%8A%E6%BA%90/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:10 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/20-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E8%A7%A3%E6%B8%8A%E6%BA%90/</guid>
      <description>23 种经典设计模式的索引对照表 设计模式的开山鼻祖 GoF 在《设计模式：可复用面向对象软件的基础》一书中提出的 23 种经典设计模式被分成了三组类别，分别是创建型模式、结构型模式和行为型模式。本书并未对这 23 种设计模式都进行了一一讲解，因为有一些设计模式在现今软件的开发中用的非常少！
随着技术的不断革新与发展，设计模式也一直在发展，有一些模式已不再常用，同时却有一些新的模式在诞生。为方便熟悉经典设计模式的读者进行快速阅读，下面对本书中提及的经典模式按照 GoF 的分类方式进行索引。
 创建型模式  工厂方法：生活中的工厂模式——你要拿铁还是摩卡 抽象工厂 单例模式：生活中的单例模式——你是我生命的唯一 构建模式：生活中的构建模式——你想要一辆车还是个庄园 原型模式：生活中的克隆模式——给你一个分身术   结构型模式  适配模式：生活中的适配器模式——身高不够鞋来凑 桥接模式 组合模式：生活中的组合模式——自己电脑组装，价格再降三折 装饰模式：生活中的装饰模式——你想怎么穿就怎么穿 外观模式：生活中的外观模式——学妹别慌，学长帮你 享元模式：生活中的享元模式——颜料很贵必须充分利用 代理模式：生活中的代理模式——帮我拿一下快递   行为型模式  职责模式：生活中的职责模式——我的假条去哪了 命令模式：生活中的命令模式——大闸蟹，走起！ 解释模式 迭代模式：生活中的迭代模式——下一个就是你了 中介模式：生活中的中介模式——找房子问中介 备忘模式：生活中的备忘模式——好记性不如烂笔头 监听模式：生活中的监听模式——一坑爹的热水器 状态模式：生活中的状态模式——人与水之三态 策略模式：生活中的策略模式——怎么来不重要，人到就行 模板模式 访问模式：生活中的访问模式——一千个读者一千个哈姆雷特    23 种经典设计模式主要是从功能和结构的角度进行分类，如下。
 创建型：关注的是对象的创建和初始化过程； 结构型：关注的是对象的内部结构设计； 行为型：关注的是对象的特性和行为。  本系列文章，则更多的是从的生活的场景和使用的频率去区分，所以并未对其进行分类。
聪明的你一定发现还有 4 种设计模式没有对应关系，这一部分的内容将会在下一章《生活中的设计模式——那些未完待续的设计模式》进行统一讲解和说明。</description>
    </item>
    
    <item>
      <title>19 访问模式：一千个读者一千个哈姆雷特</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/19-%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%8D%83%E4%B8%AA%E8%AF%BB%E8%80%85%E4%B8%80%E5%8D%83%E4%B8%AA%E5%93%88%E5%A7%86%E9%9B%B7%E7%89%B9/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:09 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/19-%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%8D%83%E4%B8%AA%E8%AF%BB%E8%80%85%E4%B8%80%E5%8D%83%E4%B8%AA%E5%93%88%E5%A7%86%E9%9B%B7%E7%89%B9/</guid>
      <description>【故事剧情】
 光阴似箭，转眼间作为 IT 狗的 Tony 已在职场上混迹快五年了，都说五年一个瓶颈，Tony 能否跳出这个瓶颈，他心里也没底，但他总觉得该留下点什么了。Tony 喜欢写博客，经常把自己对行业的看法及对应用到的技术的总结写成文章分享出来，这一习惯从大二开始一直坚持了下来，目前已经写了不少原创文章了。
喜欢写作的人都有一个共同的梦想，就是希望有一天能写出一本书。Tony 也一样，出一本畅销书是隐藏在他内心的一个梦想，时刻有一种声音在呼唤着他！这也是他能一直坚持写作的动力，正好在这五年的一个拐点，他该行动了！
Tony 真的动笔了，写起了他酝酿已久的一个主题《从生活的角度解读设计模式》，文章一经发表，便收到了很多读者的好评，同是技术圈的朋友评价：能抓住模式的核心思想、深入浅出，很有见地！做产品和设计的朋友评价：配图非常有趣，文章很有层次感！那些 IT 圈外的朋友则评价：技术的内容一脸懵圈，但故事很精彩，像是看小说或是故事集！真是一千个读者一千个哈姆雷特啊。
 用程序来模拟生活 Tony 的书是以完全一样的内容呈现给他们，但他的那些朋友却因为专业和工作性质的不同，看到了不同的内容和角度。我们用程序来模拟一下这个场景。
源码示例：
from abc import ABCMeta, abstractmethod# 引入ABCMeta和abstractmethod来定义抽象类和抽象方法class DesignPatternBook:&amp;quot;《从生活的角度解读设计模式》一书&amp;quot;def getName(self):return &amp;quot;《从生活的角度解读设计模式》&amp;quot;class Reader(metaclass=ABCMeta):&amp;quot;访问者，也就是读者&amp;quot;@abstractmethoddef read(self, book):passclass Engineer(Reader):def read(self, book):print(&amp;quot;技术狗读&amp;quot; + book.getName() + &amp;quot;一书后的感受：能抓住模式的核心思想，深入浅出，很有见地！&amp;quot;)class ProductManager(Reader):&amp;quot;产品经理&amp;quot;def read(self, book):print(&amp;quot;产品经理读&amp;quot; + book.getName() + &amp;quot;一书后的感受：配图非常有趣，文章很有层次感！&amp;quot;)class OtherFriend(Reader):&amp;quot;IT圈外的朋友&amp;quot;def read(self, book):print(&amp;quot;IT圈外的朋友读&amp;quot; + book.</description>
    </item>
    
    <item>
      <title>18 外观模式：学妹别慌，学长帮你</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/18-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%AD%A6%E5%A6%B9%E5%88%AB%E6%85%8C%E5%AD%A6%E9%95%BF%E5%B8%AE%E4%BD%A0/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:08 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/18-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%AD%A6%E5%A6%B9%E5%88%AB%E6%85%8C%E5%AD%A6%E9%95%BF%E5%B8%AE%E4%BD%A0/</guid>
      <description>【故事剧情】
 Tony 有个爱好，喜欢跑步。因为住的离北体（北京体育大学）比较近，便经常去北体跑步，校园里环境优雅、场地开阔。正直金色九月的一天，Tony 一如往常的来到北体的开放田径场，但与往常不同的是 Tony 看到了成群的学生穿着蓝色的军服在参加军训。看着这群活力四射的新生迈着整齐的步伐，忽然有一种熟悉的感觉……是的，Tony 想起了自己的大学生活，想起了自己参加过的军训，更想起了自己刚踏入大学校园的那一天！
2010 年 9 月 10 日，Tony 拖着一个行旅箱，背着一个背包，独自一人坐上了一辆前往南昌的大巴，开始了自己的大学生涯。路上遇到堵车，一路兜兜转转，到站时已经很晚了，还好赶上了学校在汽车站的最后一趟迎新接送班车，感觉如释重负！到达学校时已是下午六点多了，天色已渐入黄昏！一路舟车劳顿，身心具备的 Tony 一下车有种不知所措的感觉……
正当 Tony 四处张望寻找该去哪儿报到时，一位热情的志愿者走过来问：“你好！我是新生报到的志愿者，你是报道的新生吧！哪个学院的呢？”
Tony 有点蒙：“什么&amp;hellip;学院？”
志愿者：“你录取通知书上写的是什么专业？”
Tony：“哦，软件工程！”
志愿者：“那就是软件学院，正好我也是这个专业的，我叫 Frank，是你学长，哈哈！”
Tony：“学长好！”
志愿者：“你是一个人来的吗？一路坐车累了吧！我帮你拿行李吧！这边走，我带你去报到……”
在 Frank 的帮助下，Tony 先到活动中心完成了报到登记，然后去缴费窗口缴完学费，之后又到生活中心领了生活用品，最后再到宿舍完成入住。这一系列流程走完，差不多花了一个小时，还是在 Frank 的热心帮助下！如果是 Tony 一个人，面对这陌生的环境和场所，所花的时间更是难以想象。报道流程结束后，Frank 还带 Tony 到食堂，请他吃了顿饭，带他到校园走了半圈……
Tony 读大二、大三时，每一年新生入学时，作为老鸟的他也毅然决然地成为了迎新志愿者的一员，迎接新一届的学弟学妹！加入志愿者后，Tony 发现这里真是有不少“假”志愿者！因为要是学妹来了，一群学长都围过去，抡着去帮忙；虽然学弟也不拒绝，但明显就没了抢的姿势，在理工类学院，学姐抢学弟的事是绝对不可能发生的！
 用程序来模拟生活 9 月是所有大学的入学季，新生入学报道是学校的一项大工程，每一个学校都有自己的报道流程和方式，但都少不了志愿者这一重要角色！一来，学长学姐带学弟学妹是尊师重教的一种优良传统；二来，轻车熟路的学长学姐作为志愿者为入学新生服务，能给刚入学的新生减少了诸多不必要的麻烦。下面我们用程序来模拟一下新生报到的整个流程。
源码示例：
class Register:&amp;quot;入学报到&amp;quot;def register(self, name):print(&amp;quot;活动中心:&amp;quot; + name + &amp;quot;同学报到成功！&amp;quot;)class Payment:&amp;quot;缴费&amp;quot;def pay(self, name, money):print(&amp;quot;缴费中心:&amp;quot; + &amp;quot;收到&amp;quot; + name + &amp;quot;同学&amp;quot; + str(money) + &amp;quot;元付款，缴费成功！&amp;quot;)class DormitoryManagementCenter:&amp;quot;宿舍管理中心(生活中心)&amp;quot;def provideLivingGoods(self, name):print(&amp;quot;生活中心:&amp;quot; + name + &amp;quot;同学的生活用品已发放。&amp;quot;)class Dormitory:&amp;quot;宿舍&amp;quot;def meetRoommate(self, name):print(&amp;quot;宿 舍:&amp;quot; + &amp;quot;大家好！这是刚来的&amp;quot; + name + &amp;quot;同学，是你们未来需要共度四年的室友！相互认识一下……&amp;quot;)class Volunteer:&amp;quot;迎新志愿者&amp;quot;def __init__(self, name):self.</description>
    </item>
    
    <item>
      <title>17 享元模式：颜料很贵必须充分利用</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/17-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E9%A2%9C%E6%96%99%E5%BE%88%E8%B4%B5%E5%BF%85%E9%A1%BB%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:07 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/17-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E9%A2%9C%E6%96%99%E5%BE%88%E8%B4%B5%E5%BF%85%E9%A1%BB%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8/</guid>
      <description>【故事剧情】
 团队的拓展培训是很多大公司都组织的活动，因为素质拓展培训能将企业培训、团队建设、企业文化融入到有趣的体验活动中。Tony 所在的公司今年也举行了这样的活动，形式是团体活动 + 自由行，团体活动（第一天）就是素质拓展和技能培训，自由行（第二天）就是自主选择、轻松游玩，因为我们的活动地点是一个休闲娱乐区，还是有很多可玩的东西。
团体活动中有一个项目非常有意思，活动内容是：6 个人一组，每个组完成一幅作画，每个组会拿到一张彩绘原型图，然后根据原型图完成一幅彩绘图。素材：原型图每组一张、铅笔每组一支、空白画布每组一张、画刷每组若干；而颜料却是所有组共用的，有红、黄、蓝、绿、紫五种颜色各一大桶，足够使用。开始前 3 分钟时间准备，采用什么样的合作方式每组自己讨论，越快完成的组获得的分数越高！颜料之所以是共用的，原因也很简单，颜料很贵，必须充分利用。
Tony 所在的 梦之队 组经过讨论后，采用的合作方式是：绘画天分最高的 Anmin 负责描边（也就是素描），Tony 负责选择和调配颜料（取到颜料后必须加水并搅拌均匀），而喜欢跑步的 Simon 负责传送颜料（因为颜料放中间，离每个组都有一段距离），其他人负责涂色。因为梦之队成员配合的比较好，所以最后取得了最优的成绩。
 用程序来模拟生活 在上面的示例中，用来涂色的颜料只有有红、黄、蓝、绿、紫五大桶，大家共用相同的颜料来节约资源，我们可以通过程序来模拟一下颜料的使用过程。
源码示例：
import loggingclass Pigment:&amp;quot;颜料&amp;quot;def __init__(self, color):self.__color = colorself.__user = &amp;quot;&amp;quot;def getColor(self):return self.__colordef setUser(self, user):self.__user = userreturn selfdef showInfo(self):print(self.__user + &amp;quot;取得&amp;quot; + self.__color + &amp;quot;色颜料&amp;quot;)class PigmengFactory:&amp;quot;资料的工厂类&amp;quot;def __init__(self):self.__sigmentSet = {&amp;quot;红&amp;quot;: Pigment(&amp;quot;红&amp;quot;),&amp;quot;黄&amp;quot;: Pigment(&amp;quot;黄&amp;quot;),&amp;quot;蓝&amp;quot;: Pigment(&amp;quot;蓝&amp;quot;),&amp;quot;绿&amp;quot;: Pigment(&amp;quot;绿&amp;quot;),&amp;quot;紫&amp;quot;: Pigment(&amp;quot;紫&amp;quot;),}def getPigment(self, color):pigment = self.</description>
    </item>
    
    <item>
      <title>16 备忘模式：好记性不如烂笔头</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/16-%E5%A4%87%E5%BF%98%E6%A8%A1%E5%BC%8F%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:06 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/16-%E5%A4%87%E5%BF%98%E6%A8%A1%E5%BC%8F%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/</guid>
      <description>【故事剧情】
 经过两三年的工作，Tony 学到的东西越来越多，业务也越来越熟，终于到了他该带领一个小组进行独立开发的时候了。作为小组负责人后的 Tony，工作自然就多了：要负责技术的选型、核心代码的开发，还要深度参与需求的讨论和评审；期间还会被各种会议、面试打扰。
工作压力变大之后，Tony 就经常忙的忘了这事、忘了那事！为了解决这个问题，不至于落下重要的工作，Tony 想了一个办法：每天 9 点到公司，花 10 分钟想一下今天有哪些工作项，有哪些线上问题必须要解决的，有哪些任务需要完成的，然后把这些列一个今日待工作项（To Do List），最后就是看一下新闻，刷一下朋友圈，等到 9:30 大家来齐后开始每日的晨会，接下来就是一整天的忙碌……
因此在每天工作开始（头脑最清醒的一段时间）之前，把今天需要完成的主要事项记录下来，列一个 To Do List，是非常有必要的。这样，当你忘记了要做什么事情时，只要看一下 To Do List 就能想起所有今天要完成的工作项，就不会因忘记某项工作而影响项目的进度，好记性不如烂笔头嘛！
 用程序来模拟生活 Tony 为了能够随时回想起要做的工作项，把工作项都列到 To Do List 中做为备忘，这样就可以在因为忙碌而忘记时，通过查看 To Do List 来找回记忆。下面我们用程序来模拟一下这个示例。
源码示例：
class Engineer:&amp;quot;工程师&amp;quot;def __init__(self, name):self.__name = nameself.__workItems = []def addWorkItem(self, item):self.__workItems.append(item)def forget(self):self.__workItems.clear()print(self.__name + &amp;quot;工作太忙了，都忘记要做什么了！&amp;quot;)def writeTodoList(self):todoList = TodoList()for item in self.__workItems:todoList.writeWorkItem(item)return todoListdef retrospect(self, todoList):self.</description>
    </item>
    
    <item>
      <title>15 命令模式：大闸蟹，走起！</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/15-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%A4%A7%E9%97%B8%E8%9F%B9%E8%B5%B0%E8%B5%B7/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:05 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/15-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%A4%A7%E9%97%B8%E8%9F%B9%E8%B5%B0%E8%B5%B7/</guid>
      <description>【故事剧情】
 David：听说阿里开了一家实体店——盒马鲜生，特别火爆！明天就周末了，我们一起去吃大闸蟹吧！ Tony：吃货！真是味觉的哥伦布啊，哪里的餐饮新店都少不了你的影子。不过听说盒马鲜生到处是黑科技诶，而且海生是自己挑的，还满新奇的。
David：那就说好了，明天 11：00，盒马鲜生，不吃不散！
Tony 和 David 来到杭州上城区的一家分店。这里食客众多，物品丰富，特别是生鲜，从几十块钱的小龙虾到几百块的大青蟹，再到一千多的俄罗斯帝王蟹，应有尽有。帝王蟹是吃不起了，Tony 和 David 挑了一只 900g 的一号大青蟹。
食材挑好了，接下来就是现厂加工。加工的方式有多种，清蒸、姜葱炒、香辣炒、避风塘炒等，可以任意选择，当然不同的方式价格也有所不同。因为我们选的蟹是当时活动推荐的，所以免加工费。选择一种加工方式后进行下单，下单后会给你一个呼叫器，厨师做好了会有专门的服务人员送过来，坐着等就可以了……
 用程序来模拟生活 盒马鲜生之所以这么火爆，一方面是因为中国从来就不缺像 David 这样的吃货，另一方面是因为里面的海生很新鲜，而且可以自己挑选。很多人都喜欢吃大闸蟹，但是你有没有注意到一个问题？从你买大闸蟹到吃上大闸蟹的整个过程，可能都没有见过厨师，而你却能享受美味的佳肴。这里有一个很重要的角色就是服务员，她帮你下订单，然后把订单传送给厨师，厨师收到订单后根据订单做餐。我们用代码来模拟一下这个过程。
源码示例：
from abc import ABCMeta, abstractmethod# 引入ABCMeta和abstractmethod来定义抽象类和抽象方法class Chef():&amp;quot;厨师&amp;quot;def steamFood(self, originalMaterial):print(originalMaterial + &amp;quot;清蒸中...&amp;quot;)return &amp;quot;清蒸&amp;quot; + originalMaterialdef stirFriedFood(self, originalMaterial):print(originalMaterial + &amp;quot;爆炒中...&amp;quot;)return &amp;quot;香辣炒&amp;quot; + originalMaterialclass Order(metaclass=ABCMeta):&amp;quot;订单&amp;quot;def __init__(self, name, originalMaterial):self._chef = Chef()self._name = nameself._originalMaterial = originalMaterialdef getDisplayName(self):return self.</description>
    </item>
    
    <item>
      <title>14 策略模式：怎么来不重要，人到就行</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/14-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%80%8E%E4%B9%88%E6%9D%A5%E4%B8%8D%E9%87%8D%E8%A6%81%E4%BA%BA%E5%88%B0%E5%B0%B1%E8%A1%8C/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:04 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/14-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%80%8E%E4%B9%88%E6%9D%A5%E4%B8%8D%E9%87%8D%E8%A6%81%E4%BA%BA%E5%88%B0%E5%B0%B1%E8%A1%8C/</guid>
      <description>【故事剧情】
 Tony 在北京漂泊了三年，在这期间有很多的美好，也有很多心酸，有很多期待，也有很多失落；可终究还是要离开了，原因很简单：一来北京压力太大，生活成本太高；二来北京离家太远。离开北京，Tony 也没有回家，而是选择了新的城市——杭州。
Tony 并不是班里最早逃离北京的人，但却是毕业后仍然坚持做技术且由一线城市退居到二线城市最早的人（不是回老家或都转行）。Tony 还有十几个同学在北京，一说要离开北京，肯定是要和这些同学道别的。Tony 的学姐 Leaf（也是学校时的辅导员）为他精心组织和安排了一次聚餐，地点选在了健德门附近的一家江西餐饮——西江美食舫，大家约好晚上 19：00 不见不散……
时间和地点都定了，把能来的这些人建了一个群，大家便开始热闹地聊起来了：
Joe：我离那比较近，骑共享单车 15 分钟就到了，我可以先去点餐。
Helen：我坐地铁到那半小时，也没问题。
Henry：我有直达的快速公交到那 40 分钟，不过下班高峰期可能会堵车，时间不好说。
Ruby：我公司还有点事，可能会晚半个小时，到时我打车过去……
Leaf：怎么来不重要，人到就行！
Tony：大家有心，万分感谢，安全最重要！
 用程序来模拟生活 随着社会的发展、时代的进步，出行交通的方式可谓是越来越多样，可以说是丰富到了千奇百怪的地步了。除了上面提到的共享单车、公交车、地铁、快车（或出租车），也可以是自驾、电动车、平衡车，甚至都可以踏个轮滑、踩个滑板过来！采用什么交通方式并不重要，重要的是你能准时来共聚晚餐，不然就只能吃残羹冷炙了，哈哈！下面用代码来模拟一下大家使用不同的出行方式参加聚餐的情景吧。
源码示例：
class IVehicle:&amp;quot;交通工具的抽象类&amp;quot;def running(self):passclass SharedBicycle(IVehicle):&amp;quot;共享单车&amp;quot;def running(self):print(&amp;quot;骑共享单车(轻快便捷)&amp;quot;, end=&#39;&#39;)class ExpressBus(IVehicle):&amp;quot;快速公交&amp;quot;def running(self):print(&amp;quot;坐快速公交(经济绿色)&amp;quot;, end=&#39;&#39;)class Express(IVehicle):&amp;quot;快车&amp;quot;def running(self):print(&amp;quot;打快车(快速方便)&amp;quot;, end=&#39;&#39;)class Subway(IVehicle):&amp;quot;地铁&amp;quot;def running(self):print(&amp;quot;坐地铁(高效安全)&amp;quot;, end=&#39;&#39;)class Classmate:&amp;quot;参加聚餐的同学&amp;quot;def __init__(self, name, vechicle):self.__name = nameself.</description>
    </item>
    
    <item>
      <title>13 克隆模式：给你一个分身术</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/13-%E5%85%8B%E9%9A%86%E6%A8%A1%E5%BC%8F%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E5%88%86%E8%BA%AB%E6%9C%AF/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:03 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/13-%E5%85%8B%E9%9A%86%E6%A8%A1%E5%BC%8F%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E5%88%86%E8%BA%AB%E6%9C%AF/</guid>
      <description>【故事剧情】
 Tony 最近在看一部电视剧《闪电侠》，里面一个人物叫 Danton Black 的超级人类，拥有复制自身的超能力，能够变身出六个自己，男主角第一次与他交锋时还晕了过去。
Tony 也想要有这种超能力，这样就可以同时处理多件事啦：可以一边敲代码、一边看书、还能一边约妹，哈哈！
当然这是不可能的，虽然现在的克隆技术已经能够克隆羊、克隆狗、克隆猫，但还不能克隆人！就算可以，也不能使克隆出来的自己立刻就变成二十几岁的你，当他长到二十几岁时你已经四十几岁了，他还能理解你的想法吗？
 用程序来模拟生活 人的克隆是困难的，但程序的克隆是简单的，因为它天生就具有方便复制的特点。在程序设计中，也有一种思想是来源于克隆这一概念，它就是克隆模式。在谈这一模式之前，我们先用程序来模拟一下 Tony 这一 YY 的想法。
源码示例：
from copy import copy, deepcopyclass Person:&amp;quot;人&amp;quot;def __init__(self, name, age):self.__name = nameself.__age = agedef showMyself(self):print(&amp;quot;我是&amp;quot; + self.__name + &amp;quot;,年龄&amp;quot; + str(self.__age) + &amp;quot;.&amp;quot;)def coding(self):print(&amp;quot;我是码农，我在Coding改变世界...&amp;quot;)def reading(self):print(&amp;quot;阅读使我快乐！知识使我成长！如饥似渴地阅读是生活的一部分...&amp;quot;)def fallInLove(self):print(&amp;quot;春风吹，月亮明，花前月下好相约...&amp;quot;)def clone(self):return copy(self)测试代码：
def testProtoType():tony = Person(&amp;quot;Tony&amp;quot;, 26)tony.showMyself()tony.coding()tony1 = tony.</description>
    </item>
    
    <item>
      <title>12 构建模式：想要车还是庄园</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/12-%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F%E6%83%B3%E8%A6%81%E8%BD%A6%E8%BF%98%E6%98%AF%E5%BA%84%E5%9B%AD/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:02 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/12-%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F%E6%83%B3%E8%A6%81%E8%BD%A6%E8%BF%98%E6%98%AF%E5%BA%84%E5%9B%AD/</guid>
      <description>技术文章摘抄
  首页
  上一级
  00 生活中的设计模式：启程之前，请不要错过我.md
  01 监听模式：坑爹的热水器.md
  02 适配模式：身高不够鞋来凑.md
  03 状态模式：人与水的三态.md
  04 单例模式：你是我生命的唯一.md
  05 职责模式：我的假条去哪了.md
  06 中介模式：找房子问中介.md
  07 代理模式：帮我拿一下快递.md
  08 装饰模式：你想怎么穿就怎么穿.md
  09 工厂模式：你要拿铁还是摩卡.md
  10 迭代模式：下一个就是你了.md
  11 组合模式：自己组装电脑.md
  12 构建模式：想要车还是庄园.md
  13 克隆模式：给你一个分身术.md
  14 策略模式：怎么来不重要，人到就行.md
  15 命令模式：大闸蟹，走起！.</description>
    </item>
    
    <item>
      <title>11 组合模式：自己组装电脑</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/11-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%87%AA%E5%B7%B1%E7%BB%84%E8%A3%85%E7%94%B5%E8%84%91/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:01 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/11-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%87%AA%E5%B7%B1%E7%BB%84%E8%A3%85%E7%94%B5%E8%84%91/</guid>
      <description>【故事剧情】
 Tony 用的笔记本电脑还是大学时候买的，到现在已经用了5年，虽然后面加过一次内存，也换过一次硬盘，但仍然跟不上 Tony 对性能的要求，改变不了它被淘汰的命运，是时候该换一台新的电脑了……
换什么电脑呢？MacBook，ThinkPad，还是台式机？经过几番思考之后，Tony 还是决定买台式机，因为作为软件开发，台式机性能会更高，编译程序也会更快。确定台式机后，一个新的问题又来了，是买一个整机呢，还是自己组装呢？在反复纠结两天之后，Tony 还是决定自己亲自动手组装。一来自己也了解一些硬件知识，正好趁这次机会对自己的知识做一个检验和实践；二来自己组装能便宜一大笔钱！
于是 Tony 在京东上浏览了各个配件，花了一个星期进行精心挑选（这可真是一个精细的活，需要考虑各种型号的性能，还要考虑不同硬件之间的兼容性，还需知道各个配件的尺寸确保能正常放进机箱，因为选的是小机箱），终于确定了各个子配件：
GIGABYTE Z170M M-ATX 的主板、Intel Core i5-6600K 的 CPU、Kingston Fury DDR4 的内存、Kingston V300 的 SSD 硬盘、Colorful iGame750 的显卡、DEEPCOOL 120T 水冷风扇、Antec VP 450P 的电源、AOC LV243XIP 的显示器、SAMA MATX 小板机箱……
周末，Tony 花了一天的时间才把这些配件组装成一个完整的整机。一次点亮，Tony 成就感十足！与购买相同性能的整机相比，不仅价格减了三成，而且加深了对各个硬件的了解。
 用程序来模拟生活 只要你对硬件稍微有一些了解，或者打开过机箱换过组件，一定知道 CPU、内存、显卡是插在主板上的，而硬盘也是连在主板上的，在机箱的后面有一排的插口，可以连接鼠标、键盘、耳麦、摄像头等外接配件，而显示器需要单独插电源才能工作。我们可以用代码来模拟台式电脑的组成，这里假设每一个组件都有开始工作和结束工作两个功能，还可以显示自己的信息和组成结构。
源码示例：
class Component:&amp;quot;组件，所有子配件的基类&amp;quot;def __init__(self, name):self._name = namedef showInfo(self, indent = &amp;quot;&amp;quot;):passdef isComposite(self):return Falsedef startup(self, indent = &amp;quot;&amp;quot;):print(indent + self.</description>
    </item>
    
    <item>
      <title>10 迭代模式：下一个就是你了</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/10-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%B0%B1%E6%98%AF%E4%BD%A0%E4%BA%86/</link>
      <pubDate>Wed, 22 Dec 2021 01:37:00 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/10-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%B0%B1%E6%98%AF%E4%BD%A0%E4%BA%86/</guid>
      <description>【故事剧情】
 Tony 自小就有两颗大牙缺失、腐化，因为父母对牙齿健康的意识太缺失，一直没有治疗过。最近因为上火严重，牙齿更加疼痛，刷牙时水温稍微过低或过高都难耐无比，于是决定自己去医院看牙。
周末，Tony 带着医保卡来到空军总医院，这是 Tony 第一次走进北京这种大城市的医院。一楼大厅已经挤满了人，人数多的超过了他的想象。咨询完分诊台，花了近1个小时才排队挂上号：7楼牙科，序号0214，前面还有46人。Tony 坐电梯上了7楼，找到了对应的分诊室的位置，诊室外面等候区的座位已经坐满了人。
这里每一个诊室的医生诊断完一个病人之后，会呼叫下一位病人，这时外面的显示屏和语音系统就会自动播报下一位病人的名字。Tony 无聊地看着显示屏，下一位病人0170 Panda，请进入3号分诊室准备就诊；下一位病人0171 Lily……
因为人太多，等到12点前面仍然还有12个人，Tony 不得不下去吃个中饭，回来继续等。下一位病人0213 Nick，请进入3号分诊室准备就诊！Tony 眼睛一亮，**哎，妈呀！终于快到了，下一个就是我了！**看了一个时间，正好14:00……
 用程序来模拟生活 医院使用排号系统来维持秩序，方便医生和病人。虽然仍然需要排队，且等待是一件非常烦人的事情，但如果没有排号系统，大家都挤在诊室门口将会是更可怕的一件事！这个排号系统就像是病人队伍的大管家，通过数字化的方式精确地维护着先来先就诊的秩序。下面我们用程序来模拟这一场景。
源码示例：
class Customer:&amp;quot;客户&amp;quot;def __init__(self, name):self.__name = nameself.__num = 0self.__clinics = Nonedef getName(self):return self.__namedef register(self, system):system.pushCustomer(self)def setNum(self, num):self.__num = numdef getNum(self):return self.__numdef setClinic(self, clinic):self.__clinics = clinicdef getClinic(self):return self.__clinicsclass Iterator:&amp;quot;迭代器&amp;quot;def __init__(self, data):self.</description>
    </item>
    
    <item>
      <title>09 工厂模式：你要拿铁还是摩卡</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/09-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BD%A0%E8%A6%81%E6%8B%BF%E9%93%81%E8%BF%98%E6%98%AF%E6%91%A9%E5%8D%A1/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:59 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/09-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BD%A0%E8%A6%81%E6%8B%BF%E9%93%81%E8%BF%98%E6%98%AF%E6%91%A9%E5%8D%A1/</guid>
      <description>【故事剧情】
 Tony 工作的公司终于有了自己的休息区！ 在这里大家可以看书、跑步、喝咖啡、玩体感游戏！开心工作，快乐生活！
现在要说的是休息区里的自制咖啡机，因为公司里有很多咖啡客，所以颇受欢迎！
咖啡机的使用也非常简单，咖啡机旁边有已经准备好的咖啡豆，想要喝咖啡，只要往咖啡机里加入少许的咖啡豆，然后选择杯数和浓度，再按一下开关，10分钟后，带着浓香味的咖啡就为你准备好了！当然，如果你想喝一些其他口味的咖啡，也可以自备咖啡豆，无论你是要拿铁还是摩卡，这些都还是问题。那问题来了，你是拿铁还是摩卡呢？
 用程序来模拟生活 有人可能会说了：不就是一个咖啡机吗，有什么好炫耀的！非也非也，我只是要告诉你如何从生活的每一件小事中领悟设计模式，因为这里又隐藏了一个模式，你猜到了吗？我们还是先用程序来模拟一个上面的场景吧！
源码示例：
class Coffee:&amp;quot;咖啡&amp;quot;def __init__(self, name):self.__name = namedef getName(self):return self.__namedef getTaste(self):passclass CaffeLatte(Coffee):&amp;quot;拿铁咖啡&amp;quot;def __init__(self, name):super().__init__(name)def getTaste(self):return &amp;quot;轻柔而香醇。&amp;quot;class MochaCoffee(Coffee):&amp;quot;摩卡咖啡&amp;quot;def __init__(self, name):super().__init__(name)def getTaste(self):return &amp;quot;丝滑与醇厚。&amp;quot;class Coffeemaker:&amp;quot;咖啡机&amp;quot;@staticmethoddef makeCoffee(coffeeBean):coffee = Noneif(coffeeBean == &amp;quot;拿铁风味咖啡豆&amp;quot;):coffee = CaffeLatte(&amp;quot;拿铁咖啡&amp;quot;)elif(coffeeBean == &amp;quot;摩卡风味咖啡豆&amp;quot;):coffee = MochaCoffee(&amp;quot;摩卡咖啡&amp;quot;)else:coffee = Coffee()return coffee测试代码：</description>
    </item>
    
    <item>
      <title>08 装饰模式：你想怎么穿就怎么穿</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/08-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%BD%A0%E6%83%B3%E6%80%8E%E4%B9%88%E7%A9%BF%E5%B0%B1%E6%80%8E%E4%B9%88%E7%A9%BF/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:57 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/08-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%BD%A0%E6%83%B3%E6%80%8E%E4%B9%88%E7%A9%BF%E5%B0%B1%E6%80%8E%E4%B9%88%E7%A9%BF/</guid>
      <description>故事剧情
 工作两年后，Tony 因为换工作而搬了一次家！这是一个4室1厅1卫1厨的户型，住了4户人家。恰巧这里住的都是年轻人，有男孩也有女孩，而 Tony 就是在这里遇上了自己喜欢的人，她叫 Jenny。Tony 和 Jenny 每天都低头不见抬头见，但 Tony 是一个程序猿，天生不善言辞、不懂着装，老被 Jenny 嫌弃：满脸猥琐，一副屌丝样！
被嫌弃后，Tony 痛定思痛：一定要改善一下自己的形象，摆脱屌丝样！于是叫上自己的死党 Henry 去了五彩城……
Tony 在这个大商城中兜兜转转，被各个商家教化着该怎样搭配衣服：衬衫要套在腰带里面，风衣不要系纽扣，领子要立起来……
在反复试穿了一个晚上的衣服之后，终于找到一套还算凑合的行装：下面是一条卡其色休闲裤配一双深色休闲皮鞋，加一条银色针扣头的黑色腰带；上面是一件紫红色针织毛衣，内套一件白色衬衫；头上带一副方形黑框眼镜。整体行装虽不潮流，却透露出一种工作人士的成熟、稳健和大气！
 （图片来自网络）
用程序来模拟生活 Tony 是一个程序员，给自己搭配了一套着装：一条卡其色休闲裤、一双深色休闲皮鞋、一条银色针扣头的黑色腰带、一件紫红色针织毛衣、一件白色衬衫、一副方形黑框眼镜。但类似的着装也可以穿在其他的人身上，比如一个老师也可以这样穿：一双深色休闲皮鞋、一件白色衬衫、一副方形黑框眼镜。
我们就用程序来模拟这样一个情景。
源码示例：
class Person:&amp;quot;人&amp;quot;def __init__(self, name):self.__name = namedef getName(self):return self.__namedef wear(self):print(&amp;quot;我的着装是：&amp;quot;)class Engineer(Person):&amp;quot;工程师&amp;quot;def __init__(self, name, skill):super().__init__(name)self.__skill = skilldef getSkill(self):return self.__skilldef wear(self):print(&amp;quot;我是&amp;quot; + self.getSkill() + &amp;quot;工程师&amp;quot; + self.getName())super().wear()class Teacher(Person):&amp;quot;教师&amp;quot;def __init__(self, name, title):super().</description>
    </item>
    
    <item>
      <title>07 代理模式：帮我拿一下快递</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/07-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B8%AE%E6%88%91%E6%8B%BF%E4%B8%80%E4%B8%8B%E5%BF%AB%E9%80%92/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:56 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/07-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B8%AE%E6%88%91%E6%8B%BF%E4%B8%80%E4%B8%8B%E5%BF%AB%E9%80%92/</guid>
      <description>【故事剧情】
 八月中秋已过，冬天急速飞来……一场秋雨一场寒，十场秋雨穿上棉！在下了两场秋雨之后，Tony 已经冻的瑟瑟发抖了。周六，Tony 在京东上买了一双雪地鞋准备过冬了，但是忘了选择京东自营的货源，第二天穿新鞋的梦想又不能如期实现了。
周二，Tony 正在思考一个业务逻辑的实现方式，这时一通电话来了，“您好！圆通快递。您的东西到了，过来取一下快递！”。Tony 愣了一下，转念明白：是周六买的鞋子，本来以来第二天就能到的，所以填的是家里的地址。这下可好，人都不在家了，咋办呢？
Tony 快速思索了一下，他想起了住一起的邻居 Wendy。Wendy 是一个小提琴老师，属于自由职业者，平时在艺术培训机构或到学生家里上上课，她在家的时间比较多。于是赶紧拿起手机呼叫 Wendy 帮忙：“你好，在家吗？能帮忙拿一下快速吗？”……
万幸的是 Wendy 正好在家，在她的帮助下终于顺利拿到快递，减了不少麻烦。
 用程序来模拟生活 在生活中，我们经常要找人帮一些忙：帮忙收快递，帮忙照看宠物狗。在程序中，有一种类似的设计，叫代理模式。在开始之前，我们先来模拟一下上面的故事案例。
源码示例：
class ReceiveParcel:&amp;quot;接收包裹&amp;quot;def __init__(self, name):self.__name = namedef getName(self):return self.__namedef receive(self, parcelContent):passclass TonyReception(ReceiveParcel):&amp;quot;Tony接收&amp;quot;def __init__(self, name, phoneNum):super().__init__(name)self.__phoneNum = phoneNumdef getPhoneNum(self):return self.__phoneNumdef receive(self, parcelContent):print(&amp;quot;货物主人：&amp;quot; + self.getName() + &amp;quot;， 手机号：&amp;quot; + self.getPhoneNum())print(&amp;quot;接收到一个包裹，包裹内容：&amp;quot; + parcelContent)class WendyReception(ReceiveParcel):&amp;quot;Wendy接收&amp;quot;def __init__(self, name, receiver):super().</description>
    </item>
    
    <item>
      <title>06 中介模式：找房子问中介</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/06-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%E6%89%BE%E6%88%BF%E5%AD%90%E9%97%AE%E4%B8%AD%E4%BB%8B/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:55 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/06-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%E6%89%BE%E6%88%BF%E5%AD%90%E9%97%AE%E4%B8%AD%E4%BB%8B/</guid>
      <description>【故事剧情】
 人在江湖漂，岂能顺心如意？与大多数毕业生一样，第一份工作很难持续两年以上。Tony 也在一家公司工作了一年半后，换了一个东家。
在北京这个硕大的城市里，换工作基本就意味着要换房子。不得不说，找房子是一件烦心而累人的工作。
 你首先要知道自己要怎样的房子：多大面积（多少平米），什么价位，是否有窗户，是否有独卫。 要去网上查找各种房源信息，找到最匹配的几个户型。 之后要去电话咨询，过滤虚假信息和过时信息。 最后，也是最累人的一步，要去实地考查，看看真实的房子与网上的信息是否相符，房间是否有异味，周围设施是否齐全。这一步你可能会从东城穿越西城，再来到南城，而后又折腾去北城……想想都累！ 最后的最后，你还要与各种脾性的房东进行周旋，去讨价还价。  Tony 想了想，还是找中介算了。在北京这座城市，你几乎找不到一手房东，90%的房源信息都掌握在房屋中介手中！既然都找不到一手房东，还不如找一家正规点的中介。
于是 Tony 找到了我爱我家，认识了里面的职员 Vangie。Vangie 问了他对房子的要求。Tony 说：“18平米左右，要有独卫，要有窗户，最好是朝南，有厨房更好！价位在2000左右。”Vangie 立马就说：“上地西里有一间，但没有厨房；当代城市家园有两间，一间主卧，一间次卧，但卫生间是共用的；美和园有一间，比较适合你，但价格会贵一点。” 真是了如指掌啊！说完就带着 Tony 开始看房了……
一天就找到了还算合适的房子。但不得不再次吐槽：北京的房子真 TM 贵啊，18平米，精装修，有朝南窗户，一个超小（1m宽不到）的阳台，卫生间5人共用，厨房共用，价格要2600每月。押一付三，加一个月的中介费，一次交了一万多，要开始吃土了，内心滴了无数滴血……
 用程序来模拟生活 上面的生活场景中，Tony 通过中介来找房子，因为找房子的过程实在太繁琐了，而且对房源信息不了解。通过中介，他省去了很多麻烦的细节，合同也是直接跟中介签，你甚至可能都不知道房东是谁。
我们将通过程序来模拟一下上面找房子的过程。
源码示例：
class HouseInfo:&amp;quot;房源信息&amp;quot;def __init__(self, area, price, hasWindow, bathroom, kitchen, address, owner):self.__area = areaself.__price = priceself.__window = hasWindowself.__bathroom = bathroomself.__kitchen = kitchenself.__address = addressself.__owner = ownerdef getAddress(self):return self.__addressdef getOwnerName(self):return self.</description>
    </item>
    
    <item>
      <title>05 职责模式：我的假条去哪了</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/05-%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F%E6%88%91%E7%9A%84%E5%81%87%E6%9D%A1%E5%8E%BB%E5%93%AA%E4%BA%86/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:54 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/05-%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F%E6%88%91%E7%9A%84%E5%81%87%E6%9D%A1%E5%8E%BB%E5%93%AA%E4%BA%86/</guid>
      <description>【故事剧情】
 周五了，Tony 因为家里有一些重要的事需要回家一趟，于是向他的领导 Eren 请假，填写完假条便交给了 Eren。得到的回答却是：“这个假条我签不了，你得等部门总监同意！” Tony 一脸疑惑：“上次去参加 SDCC 开发者大会请了一天假不就是您签的吗？” Eren：“上次你只请了一天，我可以直接签。现在你是请五天，我要提交给部门总监，等他同意才可以。”
Tony：“您怎么不早说啊？” Eren：“你也没问啊！下次请假要提前一点……”
Tony 哪管这些啊！对他来说，每次请假只要把假条交给 Eren，其他的事情都交给领导去处理吧！
事实却是，整个请假的过程要走一套复杂的流程：
 小于等于2天，直属领导签字，提交行政部门； 大于2天，小于等于5天，直属领导签字，部门总监签字，提交行政部门； 大于5天，小于等于1月，直属领导签字，部门总监签字，CEO 签字，提交行政部门。   用程序来模拟生活 对于 Tony 来说，他只需要每次把假条交给直属领导，其他的繁琐流程他都可以不用管，所以他并不知道请假流程的具体细节。但请假会影响项目的进展和产品的交互，所以请假其实是一种责任担当的过程：你请假了，必然会给团队或部门增加工作压力，所以领导肯定会控制风险。请假的时间越长，风险越大，领导的压力和责任也越大，责任人也就越多，责任人的链条也就越长。
程序来源于生活，我们可以用程序来模拟这一个有趣的场景。
源码示例：
class Person:&amp;quot;请假申请人&amp;quot;def __init__(self, name, dayoff, reason):self.__name = nameself.__dayoff = dayoffself.__reason = reasonself.__leader = Nonedef getName(self):return self.__namedef getDayOff(self):return self.__dayoffdef getReason(self):return self.__reasondef setLeader(self, leader):self.__leader = leaderdef reuqest(self):print(self.</description>
    </item>
    
    <item>
      <title>04 单例模式：你是我生命的唯一</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/04-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BD%A0%E6%98%AF%E6%88%91%E7%94%9F%E5%91%BD%E7%9A%84%E5%94%AF%E4%B8%80/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:53 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/04-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BD%A0%E6%98%AF%E6%88%91%E7%94%9F%E5%91%BD%E7%9A%84%E5%94%AF%E4%B8%80/</guid>
      <description>【故事剧情】
 爱情是每一个都渴望的，Tony 也是一样！自从毕业后，Tony 就一直没再谈过恋爱，离上一次的初恋也已经过去两年。一个巧合的机会，Tony 终于遇上了自己的喜欢的人，她叫 Jenny，有一头长发，天生爱笑、声音甜美、性格温和……
作为一个程序员的 Tony，直男癌的症状也很明显：天生木讷、不善言辞。Tony 自然不敢正面表白，但他也有自己的方式，以一种传统书信的方式，展开了一场暗流涌动的追求……经历了一次次屡战屡败，屡败屡战的追求之后，Tony 和 Jenny 终于在一起了！
然而好景不太长，由于种种的原因，最后 Jenny 还是和 Tony 分开了……
人生就像一种旅行，蜿蜒曲折，一路向前！沿途你会看到许多的风景，也会经历很多的黑夜，但我们无法回头！有一些风景可能很短暂，而有一些风景我们希望能够伴随自己走完余生。Tony 经历过一次被爱，也经历过一次追爱；他希望下次能找到一个可陪伴自己走完余生的她，也是他的唯一！
 用程序来模拟生活 相信每一个人都渴望有一个纯洁的爱情，希望找到唯一的她。不管你是单身狗一个，还是已经成双成对，肯定都希望你的伴侣是唯一的！程序如人生，程序也一样，有一些类你希望它只有一个实例。
我们用程序来模拟一个真爱。
源码示例：
class MyBeautifulGril(object):&amp;quot;&amp;quot;&amp;quot;我的漂亮女神&amp;quot;&amp;quot;&amp;quot;__instance = None__isFirstInit = Falsedef __new__(cls, name):if not cls.__instance:MyBeautifulGril.__instance = super().__new__(cls)return cls.__instancedef __init__(self, name):if not self.__isFirstInit:self.__name = nameprint(&amp;quot;遇见&amp;quot; + name + &amp;quot;，我一见钟情！&amp;quot;)MyBeautifulGril.__isFirstInit = Trueelse:print(&amp;quot;遇见&amp;quot; + name + &amp;quot;，我置若罔闻！&amp;quot;)def showMyHeart(self):print(self.</description>
    </item>
    
    <item>
      <title>03 状态模式：人与水的三态</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/03-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%BA%BA%E4%B8%8E%E6%B0%B4%E7%9A%84%E4%B8%89%E6%80%81/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:52 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/03-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%BA%BA%E4%B8%8E%E6%B0%B4%E7%9A%84%E4%B8%89%E6%80%81/</guid>
      <description>【故事剧情】
 一个天气晴朗的周末，Tony 想去图书馆给自己充充电。于是背了一个双肩包，坐了一个多小时地铁，来到了首都图书馆。走进一个阅览室，Tony 看到一个青涩的小女孩拿着一本中学物理教科书，认真地看着热力学原理……女孩容貌像极了 Tony 中学的物理老师，不知不觉间 Tony 想起了他那可爱的老师，想起了那最难忘的一节课……
Viya 老师站在一个三尺讲堂上，拿到一本教科书，给大家讲着水的特性：人有少年、壮年、老年三个不同的阶段；少年活泼可爱，壮年活力四射，老年充满智慧。 水也一样，水有三种不同的状态：固态——冰坚硬寒冷，液态——水清澈温暖，气态——气虚无缥缈。更有意思的是水不仅有三种状态，而且三种状态还可以相互转换。冰吸收热量可以熔化成水，水吸收热量可以汽化为气，气释放热量可以凝华成冰……
虽然时隔十几年，但 Viya 老师那甜美的容貌和生动的讲课方式依然历历在目……
 用程序来模拟生活 水是世界上最奇特的物质之一，不仅滋润万物，更是变化万千。你很难想象冰、水、气其实是同一个东西 H2O，看到冰你可能更会联想到玻璃、石头，看到水你可能更会联想到牛奶、可乐，看到气可能更会联想到空气、氧气。三个不同状态下的水好像是三种不同的东西。
水的状态变化万千，而程序也可以实现万千的功能。那如何用程序来模拟水的三种不同状态及相互转化呢？
我们从对象的角度来考虑会有哪些类，首先不管它是什么状态始终是水（H2O），所以会有一个 Water 类；而它又有三种状态，我们可以定义三个状态类：SolidState，LiquidState，GaseousState；从 SolidState，LiquidState，GaseousState 这三个单词中我们会发现都有一个 State 后缀，于是我们会想它们之间是否有一些共性，能否提取出一个更抽象的类，这个类就是状态类（State）。这些类之间的关系大致如下：
Ok，我们已经知道了大概的关系，那就开始 Coding 实现吧，在实现的过程中不断完善。
源码示例：
class Water:&amp;quot;水(H2O)&amp;quot;def __init__(self, state):self.__temperature = 25self.__state = statedef setState(self, state):self.__state = statedef changeState(self, state):if (self.__state):# cout &amp;lt;&amp;lt; &amp;quot;由&amp;quot; &amp;lt;&amp;lt; m_pState-&amp;gt;GetStateName() &amp;lt;&amp;lt; &amp;quot;变为&amp;quot; &amp;lt;&amp;lt; pState-&amp;gt;GetStateName() &amp;lt;&amp;lt; endl;print(&amp;quot;由&amp;quot;, self.__state.getStateName(), &amp;quot;变为&amp;quot;, state.getStateName())else:print(&amp;quot;初始化为&amp;quot;, state.</description>
    </item>
    
    <item>
      <title>02 适配模式：身高不够鞋来凑</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/02-%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F%E8%BA%AB%E9%AB%98%E4%B8%8D%E5%A4%9F%E9%9E%8B%E6%9D%A5%E5%87%91/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:51 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/02-%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F%E8%BA%AB%E9%AB%98%E4%B8%8D%E5%A4%9F%E9%9E%8B%E6%9D%A5%E5%87%91/</guid>
      <description>【故事剧情】
 晚上九点半，Tony 上了地铁，准备回家，正巧还有一个空位，赶紧走向前坐下。工作一天后，疲惫不堪的他正准备坐着打个盹小睡一会儿。这时进来两个小姑娘，一个小巧可爱，一个身姿曼妙；嬉笑地聊着天走到了 Tony 的前面，Tony 犹豫了片刻后还是绅士般地给小女孩让了个座……
两个小姑娘道了声谢谢，便挤在一块坐下了，继续有说有笑地谈论着……
Amy：周末在商场里看到你和一个帅哥在一起。好你个 Nina，脱单了也不告诉姐姐我，太不够意思了！怎么……想金屋藏“娇”啊！
Nina：不是啦，也是最近刚有事，还没来得及告诉你呢。
Amy：那快说说呗！那小哥看着很高啊！
Nina：嗯，他1米85。
Amy：厉害了，你155 他185，这就是传说中的最萌身高组合啊！
Nina：嗯，走在大街上，别人都回头看我们，弄的我挺不好了意思的~
Amy：你这是身在福中不知福啊！别人就是因为想求也求不到呢！
Nina：也有很气的时候啦，有时生气想打他，结果粉拳一出去就被他的大手包了饺子。
Amy：哈哈哈哈，还有呢！
Nina：还有一件很囧的事，我一抬头总是看到他的鼻毛，他一低头总是看到我的头发屑！
Amy：哈哈哈！笑的我肚子痛了……所以你们在一起，你一定要天天洗头，他一定要天天修鼻毛咯~
Nina：是啊！可麻烦了~
Amy：看来还是我这 160 的身高最棒了！衣服可以随便挑，更重要的是我男友 175，穿上高跟鞋，我就可以挽着他的手肩并肩地走~
Nina：这就是所谓的身高不够鞋来凑吗？
Amy：不然怎么叫万能的高跟鞋呢……
Nina：好羡慕啊！在我这，高跟鞋也无能~
Amy：… …
正听的兴起时，地铁门开了。Tony 才反应过来，到站了，该下车了。Tony 赶忙往车门方向走，一不小心额头碰到了把手上，只好一手护着头往外跑，两个小姑娘相视一笑~
 用程序来模拟生活 身材苗条、长像出众是每个人梦寐以求的，尤其是女孩子！但很多人却因为先天的原因并不能如意，这时就需要通过服装、化妆去弥补。所谓美女，三分靠长相七分靠打扮！比如身高不够，就可以通过穿高跟鞋来弥补；如果本身就比较高，那穿不穿高跟鞋就没那么重要了。这里的高跟鞋就起着一个适配的作用，能让你的形象增高四、五厘米，下面我们就用代码来模拟一下高跟鞋在生活中的场景吧！
源码示例：
class IHightPerson:&amp;quot;接口类，提供空实现的方法，由子类去实现&amp;quot;def getName(self):&amp;quot;获取姓名&amp;quot;passdef getHeight(self):&amp;quot;获取身高&amp;quot;passclass HighPerson(IHightPerson):&amp;quot;个高的人&amp;quot;def __init__(self, name):self.__name = namedef getName(self):return self.__namedef getHeight(self):return 170class ShortPerson:&amp;quot;个矮的人&amp;quot;def __init__(self, name):self.</description>
    </item>
    
    <item>
      <title>01 监听模式：坑爹的热水器</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/01-%E7%9B%91%E5%90%AC%E6%A8%A1%E5%BC%8F%E5%9D%91%E7%88%B9%E7%9A%84%E7%83%AD%E6%B0%B4%E5%99%A8/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:50 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/01-%E7%9B%91%E5%90%AC%E6%A8%A1%E5%BC%8F%E5%9D%91%E7%88%B9%E7%9A%84%E7%83%AD%E6%B0%B4%E5%99%A8/</guid>
      <description>【故事剧情】
 刚刚大学毕业的 Tony 只身来到北京这个硕大的城市，开始了北漂的生活。但刚刚毕业的他身无绝技、包无分文，为了生活只能住在沙河镇一个偏僻的村子里，每天坐着程序员专线（13号线）来回穿梭于昌平区与西城区……
在一个寒冷的冬天，下班之后要坐2个小时的地铁+公交才能回到住处，Tony 拖着疲惫的身体回到家。准备洗一个热水澡暖暖身体，耐何简陋的房子中用的还是90年代的热水器。因为热水器没有警报更没有自动切换模式的功能，所以烧热水必须得守着；不然时间长了成杀猪烫，时间短了又冷成狗。无奈的 Tony 背靠着墙，头望着天花板，深夜中做起了白日梦：一定要努力工作，过两个月我就可以自己买一个智能热水器了：水烧好了就发一个警报，我就可以直接去洗操。还要能自己设定模式，既可以烧开了用来喝，可以烧暖了用来洗澡……
 用程序来模拟生活 Tony 陷入白日梦中……他的梦虽然在现实世界里不能立即实现，但在程序世界里可以。程序来源于生活，下面我们就用代码来模拟 Tony 的白日梦。
源码示例：
class WaterHeater:&amp;quot;热水器：战胜寒冬的有利武器&amp;quot;def __init__(self):self.__observers = []self.__temperature = 25def getTemperature(self):return self.__temperaturedef setTemperature(self, temperature):self.__temperature = temperatureprint(&amp;quot;current temperature is:&amp;quot;, self.__temperature)self.notifies()def addObserver(self, observer):self.__observers.append(observer)def notifies(self):for o in self.__observers:o.update(self)class Observer:&amp;quot;洗澡模式和饮用模式的父类&amp;quot;def update(self, waterHeater):passclass WashingMode(Observer):&amp;quot;该模式用于洗澡用&amp;quot;def update(self, waterHeater):if waterHeater.getTemperature() &amp;gt;= 50 and waterHeater.</description>
    </item>
    
    <item>
      <title>00 生活中的设计模式：启程之前，请不要错过我</title>
      <link>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/00-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%90%AF%E7%A8%8B%E4%B9%8B%E5%89%8D%E8%AF%B7%E4%B8%8D%E8%A6%81%E9%94%99%E8%BF%87%E6%88%91/</link>
      <pubDate>Wed, 22 Dec 2021 01:36:49 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/00-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%90%AF%E7%A8%8B%E4%B9%8B%E5%89%8D%E8%AF%B7%E4%B8%8D%E8%A6%81%E9%94%99%E8%BF%87%E6%88%91/</guid>
      <description>两年前 CSDN 出了一个产品叫 ink，旨在提供一个高质量的写作环境，那时就有写设计模式这一系列的想法了，而且也确实写了，在 ink 里写了三篇文章，后来不知道什么原因这个产品下架了，写的三篇文章也没了，这事也就一直被搁置了；直到今天，我想重新开始，以全新的方式和思路重新写这一系列内容！
 文章的特点： 从生活的小故事开始，由浅入深，逐步阐述设计模式的思想，并抽象出代码模型（骨架）。 追求的境界： 用最通俗的语言阐述最难懂的概念；用最简单的语法实现最复杂的逻辑；用最短小的代码写出最强悍的程序！  为什么叫设计模式 什么是设计模式 设计模式最初是被 GoF 于 1995 年提出的，GoF（Gang of Four，四人帮）即 Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides。他们四人于 1995 年出版了一本书《Design Patterns：Elements of Reusable Object-Oriented Software》（翻译成中文是《设计模式 可复用面向对象软件的基础》），第一次将设计模式提升到理论高度，并将之规范化，该书提出了 23 种经典的设计模式。
设计模式（Design Pattern）是一套被反复使用、多数人知晓的、无数工程师实践的代码设计经验的总结，它是面向对象思想的高度提炼和模板化，使用设计模式是为了让代码具有更高的可重用性，更好的灵活性和可拓展性，更易被人阅读和理解。GoF 提到的模式有四个基本要素：
 模式名称：助记名，方便讨论、交流、传播； 问题：该模式是用来解决哪类实际问题，即它的应用场景； 解决方案：设计的组成部分，它们之间的相互关系及各自的职责和协作方式； 效果：使用模式能达到的效果，即对使用条件的权衡取舍。  设计模式与生活有什么联系 我一直坚信：程序源于生活，又高于生活！程序的灵魂在于思维的方式，而思维的灵感来源于生活的精彩。互联网是一个虚拟的世界，而程序本身就是对生活场景的虚拟和抽象，每一个模式我都能在生活中找到他的影子。比如，说到状态模式我能想到水有冰、水、气三种状态，而人也有少、壮、老三个不同的阶段；提起中介模式我能立马想到房产中介；看到单例模式，脑海中会即刻浮现心目中的那个她……
设计模式是面向对象的高度抽象和总结，而越抽象的东西越难以理解。本系列文章的目地就是为了降低设计模式的阅读门槛，以生活中的小故事开始，用风趣的方式，由浅入深地讲述每一个模式。让你再次看到设计模式时不只是一个模式，还是生活中的一个个小确幸！程序不是冷冰冰的代码，它还有生活的乐趣和特殊意义。
为什么要学设计模式 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。所以不管你是新手还是老手，学习设计模式将对你都有莫大的帮助。
学习设计模式的理由有很多，这里只列出几个最实现的：
 摆脱面试的窘境，不管是前端工程师还是后端工程师，亦或是全端工程师，设计模式是面试时必问的一道题。 让程序设计能力有一个质的提升，不再是写一堆结构复杂、难以维护的烂代码。 对面向对象的思想有一个更高层次的理解。  如何进行学习 熟悉一门面向对象语言
首先，至少要熟悉一门面向对象的计算机语言。如果没有，请根据自己的学习爱好，或希望从事的工作，先选择一门面向对象语言（C++、Java、Python、Go 等都可以）进行学习和实战，对抽象、继承、多态、封装有一定的基础之后，再来看本系列的文章内容。
了解 Python 的基本语法
对 Python 的基本语法有一个简单了解。Python 语法非常简单，只要有一定的编程语言基础，通过下文的介绍很快就能理解的。
学会阅读 UML 图</description>
    </item>
    
  </channel>
</rss>
