<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>math on Yipsen Ye</title>
    <link>http://yipsen.github.io/tags/math/</link>
    <description>Recent content in math on Yipsen Ye</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 22 Dec 2021 01:50:24 +0800</lastBuildDate><atom:link href="http://yipsen.github.io/tags/math/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>24 结束语 数学底子好，学啥都快</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/24-%E7%BB%93%E6%9D%9F%E8%AF%AD-%E6%95%B0%E5%AD%A6%E5%BA%95%E5%AD%90%E5%A5%BD%E5%AD%A6%E5%95%A5%E9%83%BD%E5%BF%AB/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:24 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/24-%E7%BB%93%E6%9D%9F%E8%AF%AD-%E6%95%B0%E5%AD%A6%E5%BA%95%E5%AD%90%E5%A5%BD%E5%AD%A6%E5%95%A5%E9%83%BD%E5%BF%AB/</guid>
      <description>学到了最后，不知道你有没有思考过这样的问题：数学究竟意味着什么？
在回答这个问题之前，我们先看几个跟数学有关的案例或桥段。
美剧《危机边缘》第三季的第三集
一个年轻男子在邮筒上放置了一支笔，紧接着发生了一系列的连锁案件。先是笔掉在地上，导致一个老人去弯腰捡拾；接着，骑车而过的路人撞倒了老人，导致一群人围观；最后，围观群众过多，让公交车司机没注意红绿灯变化，导致撞死了一个手捧鲜花的女子。原来，这个年轻男子是个智商极高的人，通过各种精准的计算，对事情有了准确预判，完成了自己的杀人计划。
电影《决胜 21 点》
几个数学高才生，利用假期时间，在赌城拉斯维加斯，玩他们再熟悉不过的“21点”，最终狂赢三百多万的美金。他们靠记住扑克牌的分布状况推算获胜概率，并调整自己的下注策略，谋求统计上收益期望最大的策略。
综艺节目《相声有新人》
有一对博士夫妻尝试在相声中加入数学公式元素。他们认为，人类的情感可以被公式化计算，并进一步利用这些公式创作出让人产生情感共鸣的相声。虽然他们的相声并没有让我发笑，但这的确算得上是数学与相声融合的大胆尝试。
生活中的我们，总是面临各种各样的选择。
 我现在非常饿、要吃饭，是选择去可能会排队很久的网红店，还是选择去吃快速便利的麦当劳？ 今天有一些阴天，是保守地在书包里背着一把雨伞，还是激进点，不带伞轻装出行？ 等公交时来了一个不太顺路的车，是选择先上车，还是继续等待着那趟更顺路的车？  面对人生中的选择，你一定要尽可能避免用抛硬币的方式来决策人生。相反，你需要具备做出更合理的决策的能力。
 例如，你根据过往数据计算出网红店高峰排队的时间期望是 20 分钟，而麦当劳只需要 3 分钟就能完成汉堡包的出餐，那么去麦当劳吃饭也许是个更好的选择。 又如，你根据所在城市的历史天气状况数据计算发现，阴天条件下产生降水的概率 P(降水|阴天) 只有 0.05，那么激进一点，不带伞也许是个更好的选择。 再比如，你计算出不太顺路的公交车会让你多花费 10 分钟的出行时间，而“顺路车”平均 3 分钟就会来一趟，那么继续等待更顺路的车也许是个更好的选择。  你有没有发现，利用收集到的数据做一些数学计算之后，往往会让你做出的决策更合理。反过来说，有了数学的武器之后，意味着人生做出的选择会更合理。
解决问题的通用框架——形式化定义和最优化求解 我在专栏的《05 | 求极值：如何找到复杂业务的最优解？》和《07 | 线性回归：如何在离散点中寻找数据规律？》中反复提到过一个解决问题的通用框架，那就是形式化定义和最优化求解。
当你遇到一个问题时，不妨试着用一个带参数的函数，来形式化定义这个问题；接着，通过各种各样求极值的办法，求解这个函数的最优值。
通过这两个步骤，你遇到的问题就能迎刃而解。
对于这两个步骤而言，第二步最优化求解就是求函数极大值/极小值的问题，如果你还会了梯度下降法，你就能找到绝大多数的函数的极值。
而问题的关键就是第一步，如何形式化定义一个问题。
【形式化定义】 在很多人眼中，事物是不可被计算的。例如，“我无法计算出他人的内心世界”“我无法计算出下一张扑克牌的花色是什么”“我无法在事前计算出足球比赛的结果”。然而，在数学家的眼中，数学家宁愿相信一切都是可以被计算的。也许，根据 TA 与你在微信上互动的频次、TA 每天说话提到你的次数等数据，就能计算出 TA 对你的好感度。
也许，可以根据已经翻出来的几张扑克牌的花色分布，就能计算出下一张扑克牌更可能的花色是什么。也许，根据两队历史交锋结果、比赛当时的主客场因素、球队主力伤病情况等因素，就能计算出主队获胜的概率。因此，只要你相信数学，你就能让更多的问题可被形式化定义。
学生时代，你一定听过这样的几句话，“学好数理化，走遍全天下”。在我的中学时代中，也有老师说过，“物理和化学的本质是数学”；在成为一名程序员之后，也听说过“一流的程序员靠数学”的说法。
那么，为什么这些不同的学科都指向了数学呢？
这与解决问题的通用框架有关。理工类的学科，研究的是实际日常生活中的问题。如果你是一个善于运用数学思想的人，那么你一定可以让更多的问题被形式化定义出来，再用一个数学的最优化求解算法，来找到问题的答案。
也就是说，一个实际的日常生活中的问题，会被你用数学的思想来解决。有了这个本事之后，在你的眼中，不论是物理问题、化学问题、通信问题，或者是编程问题，都将会变成数学问题。那么，只要你的数学能力够强、底子够好，你就可能做到学啥都快，干啥都游刃有余。
专栏回顾 这门专栏马上就要和大家说再见了，你还记得我们与大聪明、大迷糊、大漂亮学了哪些趣味数学吗？我们一起回顾一下吧。  在公瑾的算账定律中，我们用数学计算“你”与大聪明、大漂亮、大迷糊在麻将桌上的得失。 之后，我们又在“双十一剁手算钱”和“万有引力看人缘”的故事中，了解了数学偷藏在生活和万物中的奇妙。 再之后，又用转化漏洞分析法点醒了大漂亮，提升成绩的关键；还用数学，教大迷糊如何应对公务员考试中的行测题。最重要的是，让你也明白了做事高效的奥秘；  之后，我们又加深了难度，一路升级打怪。
 白话理解“极大似然估计”“线性回归”“数学归纳法”，解决了让你学生时代头疼数年的隐讳、模糊的数学概念。 而后，我们又带着概率论滤镜观看足球赛，用信息熵计算出“阿根廷队 vs 葡萄牙队”的结果不确定性。 还帮助大迷糊计算灰度实验的收益和可靠性；用动态规划为大聪明找出最优回家路线。 寓教于乐，我们还在“汉诺塔游戏”和“多米诺骨牌”中通晓了“递归”和“归纳”的本质； 最后，又通过三个数学公式，以小见大，认识了 AI 的最简骨架。   你还记得它们出现在哪些课时吗？同学们，可以根据课时大纲回顾以上内容。</description>
    </item>
    
    <item>
      <title>23 站在生活的十字路口，如何用数学抉择？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/23-%E7%AB%99%E5%9C%A8%E7%94%9F%E6%B4%BB%E7%9A%84%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E5%AD%A6%E6%8A%89%E6%8B%A9/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:23 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/23-%E7%AB%99%E5%9C%A8%E7%94%9F%E6%B4%BB%E7%9A%84%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E5%AD%A6%E6%8A%89%E6%8B%A9/</guid>
      <description>人的一生需要面临很多重大的选择和决策，举例而言：
 大漂亮毕业一年后遇到了一个小伙靠谱哥；面对靠谱哥的追求，大漂亮是应该接受还是拒绝？ 大迷糊工作 3 年，猎头推荐给他一个不错的工作机会，面对年薪 30% 的涨幅，大迷糊是接受 offer 还是拒绝 offer？  除了这些重大决策以外，我们生活中也需要做一些小的决策。
 例如，点外卖时遇到满 30 元减 8 元，是强迫自己多消费到 30 元，还是只买自己所需的物品？ 打德州扑克的时候，面对对手的加注，是跟注还是弃牌？  其实，当你面对这些选择时，完全可以利用数学知识来做出更合理的决策。这一讲的彩蛋，我们就围绕其中的几个场景，试着从数学的角度来进行解析。
放弃还是继续，如何选择最优？ 人生充满了不确定性。在面临不确定性的时候，我们经常会面临下面的选择：是珍惜眼前，还是寄希望于未来？
举个例子，大漂亮是个各方面条件都很不错的女孩子。工作之后，她遇到一个男生靠谱哥，靠谱哥身上有优点，也有缺点，但综合来看，确实是个靠谱的年轻人。
那么，大漂亮是应该放弃靠谱哥，期待以后能遇到更优秀的男生；还是珍惜眼前，接受聪明哥的爱意，继续这段姻缘呢？
这就是一个在不确定性环境中，需要做出最优决策的问题。在这里，大漂亮面对的不确定性环境是，拒绝靠谱哥后还能不能遇到更优秀的男生。
人生的魅力就在于未来，而未来的特点就是不确定，人生中诸如此类的选择还有很多。而我们的数学家们，对这一类问题进行了抽象，总结出了经典的最优停止问题。
【最优停止问题】 最优停止问题有很多中描述方式，我们以“聘请秘书”为例来描述。
假设大聪明要聘请一名秘书，现在有 n 人来面试，其中 n 是已知的，每个候选人的能力有量化的得分。现在，这些候选人被按照随机的顺序进行面试，大聪明每次只能面试一个候选人，查看该候选人的能力得分，并需要立即决定是否聘用该候选人。
如果决定不聘用该候选人，这个候选人便不会再回来；如果决定聘用该候选人，后续的候选人就没有面试的机会了。
问：大聪明用怎样的策略，才能让他有更高的概率选到能力得分最高的候选人？
顾名思义，最优停止问题，就是面对一个又一个的输入样本，去选择一个最好的停止时刻。它有以下几个特点。
 第一，候选人只能一个接一个地面试，不能同时参加面试； 第二，面试官大聪明能且只能选择聘用 1 个候选人； 第三，面试当场，大聪明就需要做出聘用与否的决策，不能“骑驴找马”地选择待定。  接下来，我们就来通过数学的方式去计算出最优的策略。
其实，最优停止问题的答案很简单；有时候，也被人简称为“三七法则”。具体而言，是对前 m 个候选人，不论多么优秀，都拒绝聘用。接着，从第 m+1 个人开始，如果遇到了一个比先前所有面试者都优秀的候选人，那么就聘请这个人。
流程上如上图所示，而之所以被称为“三七法则”，是因为当 m/n 等于 37% 时，选到能力得分最高的候选人的概率是最大的，而且这个选中最优候选人的最大的概率也恰好是 0.37。
【代码实现】 我们先试着用代码仿真一下上面的结论。我们假设候选人的人数 n 为 100，每个候选人都有一个能力得分，取值为 0 到 1 之间的小数，则代码如下：
import randomimport numpy as npt = 0f = 0for i in range(1000):a = np.</description>
    </item>
    
    <item>
      <title>22 面试中那些坑了无数人的算法题</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/22-%E9%9D%A2%E8%AF%95%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%9D%91%E4%BA%86%E6%97%A0%E6%95%B0%E4%BA%BA%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:22 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/22-%E9%9D%A2%E8%AF%95%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%9D%91%E4%BA%86%E6%97%A0%E6%95%B0%E4%BA%BA%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <description>前面的课时，我们学习了“代数与统计”“算法与数据结构”，至今这门课程的主体知识已告一段落，下面我们进入彩蛋环节，我会向你介绍两个应用到数学的场景，第一个是求职面试，第二个是做人生规划。
这一讲，我们先聊一聊求职面试时常见的数学题。
毕业后，相信你一定参加过不少的面试吧。在求职面试的时候，即使目标工作岗位很少需要直接使用数学知识，也依然有不少面试官非常注重候选人的数学水平，而这并不是没有依据的。因为绝大多数的岗位，都需要候选人具有逻辑推理能力和解决问题的能力。而这些能力在数学上都能有所体现。
下面，我们通过三个例题，带大家体验一下面试中的数学。
例题1 抛硬币问题 假设你和大漂亮在玩抛硬币游戏。硬币的正面朝上可得 1 分，背面朝上则分数不变。如果大漂亮可以抛 51 次硬币，而你只能抛 50 次硬币，那么大漂亮分数比你高的概率是多少？
这个问题如果用计算机进行仿真求解，就会非常容易，我们给出下面的代码。
import randomdapiaoliang = 0you = 0win = 0for _ in range(1000):for _ in range(51):if random.randint(0,1) == 1:dapiaoliang += 1for _ in range(50):if random.randint(0,1) == 1:you += 1if dapiaoliang &amp;gt; you:win += 1dapiaoliang = 0you = 0print win我们对代码进行走读：
 第 3、4 行，分别定义两个变量来保存大漂亮和你的得分； 第 5 行，用 win 变量来记录大漂亮获胜的次数； 第 6 行开始，执行一个重复 1000 次的循环； 在每次的循环内部，先在第 7～9 行，通过 51 次的循环，模拟出大漂亮的得分； 再在第 10～12 行，通过 50 次的循环，模拟出你的得分； 在 13、14 行判断，如果大漂亮分数比你高，则大漂亮获胜一局。  最终，打印出大漂亮获胜的局数。我们运行代码的结果如下图。</description>
    </item>
    
    <item>
      <title>21 神经网络与深度学习：计算机是如何理解图像、文本和语音的？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/21-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9B%BE%E5%83%8F%E6%96%87%E6%9C%AC%E5%92%8C%E8%AF%AD%E9%9F%B3%E7%9A%84/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:21 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/21-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9B%BE%E5%83%8F%E6%96%87%E6%9C%AC%E5%92%8C%E8%AF%AD%E9%9F%B3%E7%9A%84/</guid>
      <description>在上一讲的最后，我们提到过“浅层模型”和“深层模型”。其实，人工智能的早期并没有“浅层模型”的概念，浅层模型是深度学习出现之后，与之对应而形成的概念。在浅层模型向深层模型转变的过程中，神经网络算法无疑是个催化剂，并在此基础上诞生了深度学习。
这一讲，我们就来学习一下神经网络和深度学习。
神经网络的基本结构及其表达式 回想一下上一讲我们学的决策树，理论上来看，只要一直递归，一层又一层地寻找分裂变量，决策树做出预测的准确率是可以达到 100% 的。可见，这种层次化建立模型的思想，是不断提高模型效果的重要手段。
然而，对于决策树而言，AI 框架的第一个公式 y = f(w;x)，只能被“画出”却很难用被写出。而这背后的原因，其实是决策树是一种类似于“if-else-”的条件分支结构，这本身就不是一种基于函数的数学表达形式。
那么我们不禁会想，有没有哪个模型既能保留层次化建模提高效果的优势，又能拥有基于函数的数学表达形式呢？
答案，就是神经网络。
神经网络是一种具有层次化结构的模型，它的设计来自生物学中对于人类大脑的研究。我们知道，神经元是人脑的基本结构，众多神经元组织在一起，就构成了人的大脑。
1.神经元，神经网络的基本单位 神经网络的结构与人类大脑结构非常相似，它的基本单位是函数化的神经元，再通过层次化地把这些神经元组织在一起，就构成了神经网络的表达式。
如下图，就是神经网络的神经元。
我们假设输入变量有两个。
 实际中如果输入变量较多，只需要增加输入变量 xi 和权重系数 wi 的链接就可以了。
 图中，x1 和 x2 是两个输入变量，它们分别与两个系数变量 w1 和 w2 相乘之后，指向了“+”号的模块。
得到了加权求和的结果之后，需要输入到一个 Sigmoid 函数中，最右的 y 就是这个神经元的输出，即
有了神经元的表达式之后，我们把图中虚线框的神经元用一个圆形的结点来进行封装，再把输出 y 写入这个结点中，这样就有了下面的表示形式。
2.层次化将“神经元”构成神经网络 我们说过，层次化地把多个神经元组织在一起，才构成了神经网络。在这里，层次化的含义是，每一层有若干个神经元结点，层与层之间通过带权重的边互相连接。如下图，就是一个简单的神经网络。
在这个神经网络中，输入变量有 3 个，分别是 x1、x2 和 x3。结点与结点之间，由带箭头的边连接，每条边都是一个权重系数 wijk。作用是将前面一个结点的输出，乘以权重系数后，输入给后面一个结点中。
 这里 wijk 的含义，是第 i 层的第 j 个结点到第 i+1 层的第 k 个结点的权重。
 网络中，除了最后一个结点以外，其余结点的输出都是临时结果；且每个临时结果，都将成为下一层神经元结点的输入。而最后一个结点的输出，也就是最终模型的输出 y。
对于神经网络而言，它既可以用图画的方式“画出”模型的结构，也可以通过函数化的形式写出输入和输出的关系，上图中的表达式如下。
y = y3 = sigmoid(y1w211+y2w221)</description>
    </item>
    
    <item>
      <title>20 决策树：如何对 NP 难复杂问题进行启发式求解？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/20-%E5%86%B3%E7%AD%96%E6%A0%91%E5%A6%82%E4%BD%95%E5%AF%B9-np-%E9%9A%BE%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E8%BF%9B%E8%A1%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B1%82%E8%A7%A3/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:20 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/20-%E5%86%B3%E7%AD%96%E6%A0%91%E5%A6%82%E4%BD%95%E5%AF%B9-np-%E9%9A%BE%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E8%BF%9B%E8%A1%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B1%82%E8%A7%A3/</guid>
      <description>这一讲，我们学习决策树模型。决策树模型既可以解决分类问题，也可以解决回归问题，经典的决策树算法有 ID3、C4.5，以及 CART 算法。
当今主流的人工智能模型都是基于决策树的模型，例如更复杂的梯度提升决策树、随机森林等等。这些模型有着更加复杂、深厚的数学机理，但本质上还是决策树的思想。
决策树及其基本结构 决策树算法采用树形结构，使用层层推理来实现最终的分类。与逻辑回归不同，决策树模型很难用一个函数来描述输入向量_x_和预测类别 y 之间的关系。但是，如果利用一个如下图的树形状图形，就能很轻松描述清楚。
决策树
我们可以发现决策树有以下特点。
决策树由结点和边组成。最上边的结点称作根结点，最下边的结点称作叶子结点。除了叶子结点外，每个结点都根据某个变量及其分界阈值，决定了是向左走或向右走。每个叶子结点代表了某个分类的结果。
 当使用决策树模型去预测某个样本的归属类别时，需要将这个样本从根结点输入； 接着就要“按图索骥”，根据决策树中的规则，一步步找到向左走或向右走的路径； 直到最终，最终到达了某个叶子结点中，并用该叶子结点的类别表示预测结果。  例如，大迷糊的头发长度为 6 厘米、指甲长度为 0.1 厘米，我们要预测大迷糊的性别。从根结点出发，因为大迷糊的头发长度大于 5 厘米，则向左走；又因为大迷糊的指甲长度小于 1 厘米，则向右走。最终抵达叶子结点为男性，这就是预测的结果。
决策树建模的挑战 我们曾说过，利用人工智能建模就是建立假设，再去找到假设条件下的最优化参数。对于决策树而言，它的假设就是输入向量_x_和输出类别 y 之间是一棵树的条件判断关系。
这样来看，决策树模型的参数就是每个结点的分裂变量和分裂变量的阈值。决策树建模，就是要找到最优的模型参数，让预测结果尽可能更准。然而，在使用决策树建模时想最优的模型参数是个 NP 难的问题。
NP 难问题，指最优参数无法在多项式时间内被计算出来，这很像我们先前所说的指数爆炸。NP 难问题是数学界的一类经典问题，我们这里进行简单介绍。
例如，旅行商问题（Travel Saleman Problem or TSP）就是个典型的 NP 难问题。旅行商问题，是指一个旅行商需要从 A 城市出发，经过 B 城市、C 城市、D 城市等 n 个城市后， 最后返回 A 城市，已知任意两个城市之间的路费 xij。
问：这个旅行商以怎样的城市顺序安排旅行，能让自己的路费最少。
这个旅行商问题显然就是一个 NP 难问题，这体现在两个方面。
 第一，任意给出一个行程安排，例如 A-&amp;gt;B-&amp;gt;D-&amp;gt;C-&amp;gt;A，都可以很容易算出旅行路线的总费用； 第二，但是要想找到费用最少的那条路线，最坏情况下，必须检查所有可能的路线，而这里可能的路线是 (n-1)! 个。   例如，3 个城市的路线有 A-&amp;gt;B-&amp;gt;C-&amp;gt;A、A-&amp;gt;C-&amp;gt;B-&amp;gt;A 两种可能，搜索空间决定了时间复杂度，显然复杂度是 O(n!</description>
    </item>
    
    <item>
      <title>19 逻辑回归：如何让计算机做出二值化决策？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/19-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%81%9A%E5%87%BA%E4%BA%8C%E5%80%BC%E5%8C%96%E5%86%B3%E7%AD%96/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:18 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/19-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%81%9A%E5%87%BA%E4%BA%8C%E5%80%BC%E5%8C%96%E5%86%B3%E7%AD%96/</guid>
      <description>在上一讲，学习完 AI 的基本框架后，我们现在就开始围绕当前人工智能领域最常用的模型，来分别学习一下它们背后的原理。
这一讲，我们从最常见的逻辑回归模型说起，逻辑回归是人工智能领域中入门级的基础模型，它在很多领域都有应用，例如用户的信贷模型、疾病识别等。
逻辑回归是一种分类模型，可以对一个输入 x，识别并预测出一个二值化的类别标签 y。例如，要预测照片中人物的性别，可以采用逻辑回归建立模型。给模型输入一个描述照片的特征向量 x，经过模型的计算，可以得到输出值 y 为“男”或“女”。
在深入学习逻辑回归的原理之前，我们先来了解一下什么是分类问题，以及分类问题有哪些类型。
分类问题 在人工智能领域中，分类问题是特别常见的一种问题类型。简而言之，分类问题就是对一个测试验本去预测它归属的类别。例如，预测胎儿性别、预测足球比赛结果。
根据归属类别可能性的数量，分类问题又可以分为二分类问题和多分类问题。
 二分类问题，顾名思义就是预测的归属类别只有两个。例如，预测性别男/女、预测主场球队的胜负、预测明天是否下雨。 多分类问题，预测的归属类别大于两个的那类问题。例如，预测足球比赛结果是胜、负，还是平局；预测明天天气是雨天、晴天，还是阴天。  在研究分类的建模算法时，人们往往会从二分类问题入手，这主要是因为多分类问题可以用多个二分类问题来表示。例如，预测明天天气是雨天、晴天，还是阴天，这是个多分类问题（三分类）；它也可以表示为，预测明天是否下雨、预测明天是否晴天、预测明天是否阴天，这三个二分类问题。
因此，二分类问题是分类问题的基础，在讨论分类算法时，人们往往会从二分类问题入手。
逻辑回归及其建模流程 逻辑回归（Logistic Regression，LR）是人工智能领域非常经典的算法之一，它可以用来对二分类问题进行建模，对于一个给定的输入，可以预测其类别为正 1 或负 0。接下来，我们就从 AI 基本框架的 3 个公式，来学习一下 LR 的建模流程。
重温一下人工智能基本框架的 3 个公式分别是：
 第一步，根据假设，写出模型的输入、输出关系 y = f(w; x)； 第二步，根据偏差的计算方法，写出描述偏差的损失函数 L(w)； 第三步，对于损失函数，求解最优的参数值，即 w*= argmin L(w)。  接下来，我会逐一展示这三步的过程。
1.模型的输入、输出关系（Sigmoid 函数） 在逻辑回归中，第一个公式的表达式非常简单，为 y=f(w;x)=sigmoid(w·x)=1/(1+e-w·x)。
直观上来看，逻辑回归的模型假设是，把模型参数向量 w 和输入向量 x 的点乘（即线性变换）结果输入给 Sigmoid 函数中，即可得到预测值 y。
此时的预测值 y 还是个 0～1 之间的连续值，这是因为 Sigmoid 函数的值域是 (0,1)。逻辑回归是个二分类模型，它的最终输出值只能是两个类别标签之一。通常，我们习惯于用“0”和“1”来分别标记二分类的两个类别。
在逻辑回归中，常用预测值 y 和 0.</description>
    </item>
    
    <item>
      <title>18 AI 入门：利用 3 个公式搭建最简 AI 框架</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/18-ai-%E5%85%A5%E9%97%A8%E5%88%A9%E7%94%A8-3-%E4%B8%AA%E5%85%AC%E5%BC%8F%E6%90%AD%E5%BB%BA%E6%9C%80%E7%AE%80-ai-%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:17 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/18-ai-%E5%85%A5%E9%97%A8%E5%88%A9%E7%94%A8-3-%E4%B8%AA%E5%85%AC%E5%BC%8F%E6%90%AD%E5%BB%BA%E6%9C%80%E7%AE%80-ai-%E6%A1%86%E6%9E%B6/</guid>
      <description>你知道，你的网购 app 是如何成为你肚中蛔虫，向你“智能推荐”你的心仪之物的吗？地图 app 又是如何“智能预测”，你家门口的每日交通状况的吗？
如今 AI 变得无所不知，但原因并不是它真的能“窥探”万物，仅仅是因为它学会了从“数据”中学习，寻得了万物的规律。你与“淘友们”的浏览、购买数据，让它了解了你这个类群消费者的偏好；你与“出行者们”的日复一日的交通记录，让它轻松掌握所有人的出行规律。
所以 AI 的本质就是“从大数据中学习”，那么想要了解 AI，是不是真的需要先用千万级的数据练手呢？不是的。接下来我仅用四对数据，便能从中带你找出“人工智能建模框架”的关键公式。
这一模块，我们就开始从数学的视角来学习一下人工智能。
从“身高预测”认识 AI 本质 我们先来看一个最简单的人工智能的例子。有四对父子，他们的身高分别如下表所示，假设孩子的身高与父亲的身高之间是线性关系，试着用前三对父子身高的关系推算出第四对父子中儿子的身高。
我们可以利用 Excel 绘制散点图的方法拟合，也可以用先前所学的线性回归进行拟合。不管哪种方法，拟合的结果都是儿子的身高 = 父亲的身高+3。我们根据这个关系可以推算出，对于身高 182 的父亲，他的孩子更有可能的身高是 185。
其实，这就是一个用人工智能解决问题的案例。人工智能，是让机器对数据进行计算，从而得到经验（这很像人类对书本知识的学习），并利用经验对未知事务做出更智能的决策。
在这个例子中，我们对前三对父子身高关系进行计算，得到了“儿子的身高 = 父亲的身高 + 3”的经验；再用这个经验，对身高为 182 的父亲的孩子身高做出更合理、智能的决策结果。
可见，人工智能的目标就是要做出更合理、智能的决策。它的途径是对数据的计算，当然数据量越多越好，这也是“大数据”的核心优势。它的产出结果就是经验，有时候也叫作模型。换句话说，人工智能就是要根据输入的数据，来建立出效果最好的模型。
人工智能建模框架的基本步骤 既然我们说，人工智能就是要建立模型，那究竟该怎么建立呢？有没有一些通用的方法或者步骤呢？
答案是，有的。我们接下来，以前面预测孩子身高为例，再结合人工智能的定义，来试着总结出人工智能建立模型的步骤。
人工智能要通过数据来建立模型，那么数据是什么呢？其实，就是这三对父子的身高，这也是我们建模的输入。那么模型又是什么呢？模型是用来做预测的经验，其实这就是基于某个输入的自变量，来预测与之对应的因变量的函数，即 y=f(x)。
在这个例子中加了一个假设，那就是父子之间的身高关系是线性的，这就意味着 f(x) 有线性函数的表现形式，其通式是 kx+b，也就是说 y=f(x)=kx+b。
 当然，这个假设也可以是二次多项式的、指数型的。
 此时可以发现，给定某个自变量 x 时，对因变量 y 的结果起到决定性作用的是参数 k 和 b。也就是说，模型的参数（k 和 b）与自变量 x，共同决定了因变量 y 的值。
因此，有时候人们也喜欢把上面的模型写作 y=f(w;x)。在这里_w就代表了模型的参数，它可以是个标量，也可能是个向量，取决于模型的参数有多少个。像此时有 k 和 b 两个参数，那么w_就是个向量，定义为 [k,b]。
人工智能的目标是要让模型预测的结果尽可能正确，而决定模型预测结果的就是模型的参数。因此，建模的过程更像是找到最合适的参数值，让模型的预测结果尽可能正确。
这句话有些隐讳，我们尝试用数学语言来描述它。
围绕“模型预测结果尽可能正确”，就是说预测的结果和真实的结果之间的偏差尽可能小，我们就需要用一个数学式子来表达。在先前的课时中，我们提到过利用平方误差来描述两个值的偏差程度，即 (y1-y2)2，代入到这里就是 (y-ŷ)2。</description>
    </item>
    
    <item>
      <title>17 动态规划：如何利用最优子结构解决问题？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:16 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/</guid>
      <description>动态规划是运筹学问题，运筹学又是数学的一个分支，与“运筹帷幄、决胜千里”的含义很接近；同时，动态规划也是计算机技术的问题，对于程序员而言，能灵活运用动态规划解决复杂问题是一项进阶的能力。在一线互联网公司的程序员面试中，动态规划的考核绝对是一大难点。
这一讲，我们就从数学的视角学习动态规划，并通过代码完成动态规划问题的开发。
从路线规划，看动态规划问题 动态规划是动态地解决某类复杂问题的方法。
 规划，也可以理解为是计划，是对于某个复杂问题解决方案的计划或方法； 动态，是说这个复杂问题会随着执行动作的不同而产生变化，并非一成不变的。  我们举个例子，假设大聪明要自己开车从学校回家，他有很多条路线可以走，那么他的目标是走哪条路能让他最快到家。
大聪明从学校出发后，到达了一个路口，这时他选择左转或者直行都是可以到家的。如果此时左转是红灯，直行是绿灯，这是否意味着大聪明应该选择直行的路线回家呢？ 显然并不是。如果直行后的路线是极其拥堵的，而左转虽然需要等待几分钟的红灯，但随后的路线却畅通无阻。那么对于最快到家的目标而言，等一会左转的红灯，也许是更好的选择。
 其实，这里对于回家路线的规划，就是很多导航软件要解决的问题。
 从动态规划的视角来看，动态规划的目标是希望从很多可选方案中，用最小的代价找到最优的方案，动态规划处理的问题一般是动态变化的。
 一方面，原始问题包含了多个阶段的子问题。例如大聪明回家的路线需要经过 5 个路口，这就意味着大聪明需要做 5 次决策，也就是回家的大问题包含了 5 个子问题。 另一方面，每个阶段做出的决策结果，都会对后面的阶段产生影响；例如大聪明第一个路口选择了左转，这就导致直行道路的后续路口已经不在决策范围内了。  动态规划问题的特点 动态规划问题具备很多特点。例如上面提到的“多阶段”“动态变化”，除此之外还有“最优子结构”“子问题重叠”和“无后效性”。
 很多教材对这些概念的介绍特别难以理解，我们仍然以大聪明回家的例子，来试着说明这3个特点的含义。
  最优子结构  最优子结构特点是动态规划问题求解的关键。子结构，就是子问题的解。最优子结构的含义是说，如果某个解是最优的，那么这个解的子集也是对应子问题的最优解。
例如，在大聪明从学校回家的最优路线中，需要经过某个商场。那么最优的路线就可以拆分为，学校到商场（标记为 Path 1）和商场到家（标记为 Path 2）这两段路程。在其他所有学校到商场的可能路线中，Path 1 就是最近的；在其他所有商场到家的可能路线中，Path 2 就是最近的。也就是从整体看，这个长路线是最优的，那么这个长路线之下的分路线对应到其他长路线的平行分路线中也是最优的。
 子问题重叠  子问题重叠，是指原问题的若干子问题之间并不是独立的，而是彼此存在着重叠的，这是动态规划区别于“分治法”的关键所在。
如果子问题是不重叠的，那么就可以用《16 | 二分法：如何利用指数爆炸优化程序？》中讲过的“分治法”来解决；而如果子问题是重叠的，可重叠的问题根本就分不开，也就无法应用分治法了。
例如，大聪明从学校回家会途径商场，第一个子问题是第一个路口是向左转还是直行，而不管是左转还是直行，都会有途径商场的可能，这也就是说左转或直行的结果是存在重叠的。
 无后效性  无后效性，指的是未来只取决于现在，与过去无关。
例如，大聪明从学校回家，他左拐右拐到了商场。之后需要决策的就是如何从商场尽快回家。这个决策，与大聪明之前是如何到达商场的，没有任何关系。
动态规划问题的切入点——最优子结构 我们先前学的分治法，无法处理具有子问题重叠性质的问题。
但“最优子结构”的特点，能让我们分阶段去求解最优子问题，因此求解动态规划问题的切入点就是最优子结构。
具体而言，我们可以先找到某个阶段的全部可行解集合，例如左转、直行、右转，这就是个集合。对于任意一个可行解，假设是直行，则可以把从学校到家的行程，分解为学校到第一个路口后直行，以及直行后再到家，这样就形成了一个最优子结构。
接下来，我们要找到全局损耗最少的回家路线，那么就只要在所有的最优子结构中，找到损耗最少的那个就完成了一次的迭代。
由于动态规划的“无后效性”，我们只需要不断往前迭代下一个阶段，直到最终到家就找到了问题的答案。
上面的描述可能会很抽象，我们结合上述大聪明回家的最短路线问题为例展开实战，来试着更深层次理解动态规划的解决方案。
【最短路线问题的求解】 最短路线问题定义如下：给定一个网络，以及网络中可通行两点之间的消耗，求起点到终点的最少消耗。在“大聪明”问题中，每个结点就是大聪明回家可能遇到的路口，消耗就是时间，起点是学校，终点是家。
例如在下面的图中，A 是学校，G 是家，Bi、Ci、Di、Ei、Fi 是所有可能的路口，每条边是路口到路口需要消耗的时间。最短路径问题，就是希望用动态规划的办法，找到从起点到终点，最小消耗的路径所对应的时间。
我们在下面的过程结点图中，按照从 A 需要几条，归类为 B、C、D、E、F 这 5 类。例如，C 类的结点 Ci，都是从 A 经过两条到达的结点。这样的标记方法，可以将 A 到 G 的复杂问题，拆分为 A 到 B、B 到 C&amp;hellip;&amp;hellip;直到 F 到 G 的 6 个子问题。每个阶段的起点是一个状态，终点是另一个状态。因此，总共有 7 个可能的状态，分别对应 A、B、C、D、E、F、G。 过程结点图</description>
    </item>
    
    <item>
      <title>16 二分法：如何利用指数爆炸优化程序？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/16-%E4%BA%8C%E5%88%86%E6%B3%95%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%8C%87%E6%95%B0%E7%88%86%E7%82%B8%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:15 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/16-%E4%BA%8C%E5%88%86%E6%B3%95%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%8C%87%E6%95%B0%E7%88%86%E7%82%B8%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F/</guid>
      <description>正式讲课之前，我先问你这样一个问题，请你尽可能快速回答。
 一张 1 毫米厚度的纸，对折几次后，可以达到地球到月球的距离（39 万公里）？
 我在写这篇稿子的时候，问了身边的几个朋友。最小的回答是 1 万次，最大的则是 100 万次。
请问在你的直觉下，你的答案又是多少呢？我猜想无论如何都是上万次吧，毕竟我们离月球有 39 万公里呢。
折纸的过程就是 1 变 2，2 变 4，4 变 8，这样一个翻一倍的过程。聪明的你，会发现其实这就是一个关于指数函数和对数函数的问题。
那么，这与我们的编程有什么关系吗？其实基于这个数学原理，编程中有一种分治法的二分策略。这一讲，我们就来讨论一下如何利用指数爆炸来优化程序。
折纸，飞奔到月球 接下来，我们定义下面的数学符号。n 为折叠的次数，h(n) 为纸张对折 n 次后的厚度。显然，每次对折纸张时，厚度都会增加一倍。
不对折时，纸张的厚度为 h(0)=1mm；每次对折纸张时，厚度都会增加一倍；如果将纸对折 1 次，则厚度为 h(1)=2mm；如果对折 2 次，则厚度为 h(2)=4mm；对折 3 次，厚度为 h(3) = 8mm。
我们耐着性子继续往下计算，可以得到下面的对折次数与厚度的关系表。 到这里我们发现，对折 10 次后，厚度也不过才刚刚达到 1 m。也许你会不仅感慨，以这样的速度，何时才能到达月球啊。
还是耐着性子，我们继续计算，并整理为下面的表格。区别是，这次我们以米（m）为单位。 这时候，也许你会发现一些端倪。对折 10 次是 1 m，对折 20 次竟然到了 1 公里，成长速度非常快。
接着，我们继续耐着性子来计算，并整理为下面的表格。区别是，这次我们以千米（km）为单位。 我们知道地球到月亮的距离是 38 公里，也就是 3.8×105km，对折 30 次后，厚度竟然已经达到了 103km。虽然离月球仍然很远，但结合这个增长速度，感觉已经快到月球了。
我们继续耐着性子来计算，并整理到下面的表格中。区别是，这次我们以 103km 为单位。 此时，你就会看到一个惊天结果。对折 40 次后，厚度达到了 106km。这已经超过了地月距离的 3.</description>
    </item>
    
    <item>
      <title>15 递归：如何计算汉诺塔问题的移动步数？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/15-%E9%80%92%E5%BD%92%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%AD%A5%E6%95%B0/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:14 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/15-%E9%80%92%E5%BD%92%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%AD%A5%E6%95%B0/</guid>
      <description>递归是重要的程序开发思想，比如程序源代码缩进、树形数据结构、XML 语法、快速排序法等都有递归的影子。
那么，递归思维的本质到底是什么呢？递归的理念看似隐讳，实则非常清晰明了。
为了让你由浅入深地理解它，这一讲我会先从“汉诺塔问题”入手，带你找出“递归思维”，然后将其应用在两个经典问题中，让你感受递归的作用及其缺点。
最后，你便会发现递归与上一讲所学的循环有相似之处，我便会在这两者的对比辨析中，带你探讨它们的本质差异。
汉诺塔问题及其代码实现 我们先来看下汉诺塔问题的规则。
 假设有 A、B、C 三根柱子。其中在 A 柱子上，从下往上有 N 个从大到小叠放的盘子。我们的目标是，希望用尽可能少的移动次数，把所有的盘子由 A 柱移动到 C 柱。过程中，每次只能移动一个盘子，且在任何时候，大盘子都不可以在小盘子上面。
 1.汉诺塔问题解密 这个题目需要一定的窍门，否则只能碰运气去乱走了。
我们先脑补这样一个画面：假设 A 柱子上除了最后一个大盘子（代号“大盘子”）以外，其他的 N-1 个小盘子都合并起来，成为一个新的盘子（代号为“合并盘”）。那这个问题就简单了，只需要把“合并盘”移动到 B 柱，再把“大盘子”移动到 C 柱，最后把“合并盘”移动到 C 柱。
上述过程如下图所示：
在这个过程中，问题由全部 N 个盘子由 A 移动到 C，转变为 N-1 个“合并盘”从 A 移动到 B 再移动 C。新的问题和原问题是完全一致的，但盘子数量由 N 个减少为 N-1 个。如果继续用上面的思想，就能把 N-1 个“合并盘”再度减少为 N-2 个，直到只剩一个。
我们用数学重写上面的过程：令 H(x) 表示把某个柱子上的全部 x 个盘子移动到另一个柱子上需要的步数，那么原问题 N 个盘子由 A 柱子移动到 C 柱子的数学表示就是 H(N)。
根据我们第一次的分解可知 H(N)=H(N-1)+1+H(N-1)。
 也就是，把 N 个盘子从 A 移动到 C=把合并盘从 A 移动到 B + 把大盘子从 A 移动到 C + 把合并盘从 B 移动到 C。</description>
    </item>
    
    <item>
      <title>14 程序的循环：如何利用数学归纳法进行程序开发？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/14-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:13 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/14-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</guid>
      <description>我们在上一讲提到程序有顺序、选择、循环这三大基本结构，而在这其中，循环是处理复杂运算最有效的一种结构。
循环结构可以用短短几行代码，执行成千上万次的运算。从计算机编程的视角来看，循环结构又有三种实现方法，分别是 for 循环、while 循环和 do while 循环；而从数学视角来看，循环结构很像是数学归纳法。
所以这一讲，我们就从数学的视角来重新看待循环结构。
从“多米诺骨牌”看循环归纳思想 在多米诺骨牌的游戏中，游戏者手动推倒第一个骨牌，接着第一个骨牌就会撞倒第二个骨牌，第二个骨牌还会撞倒第三个骨牌。以此类推，即使骨牌数量再多，也会逐一被放倒。
我们对多米诺骨牌全部放倒的结果进行剖析，你会发现它成立的条件有以下两个：
 第一，对于任意第 i 个骨牌而言，它的倒下能带动第 i+1 个骨牌倒下； 第二，有一个参与游戏的人手动推倒第一个骨牌。  只要这两个条件都满足，就能让全部的骨牌都倒下。
“循环”的思想也存在我们的古文化中，《愚公移山》的“虽我之死，有子存焉。子又生孙，孙又生子；子又有子，子又有孙；子子孙孙无穷匮也。”简而言之就是，我有儿子，我儿子也有儿子，我儿子的儿子也会有儿子。以此类推，子子孙孙无穷尽。
在这其中不难发现，子子孙孙无穷匮的条件也有两个：
 第一，任意一代男子（或者说是儿子），都要再生至少一个儿子； 第二，愚公有个儿子。  只要这两个条件都满足，就可以做到子子孙孙无穷匮也。
数学归纳法 对这两个例子的两个条件进行抽象，你会发现这就是高中学习的数学归纳法，下面我们用数学语言描述一下。
最简单常见的数学归纳法是，用来证明当 n 等于任意一个自然数时某个命题成立，其证明步骤可以分下面两步：
 第一，当 n=1 时，命题成立； 第二，假设对于任意一个数字 i 命题成立，可以推导出在对于 i+1，命题依然成立。  只要这两个条件都满足，命题就得证。
例如，要证明所有的多米诺骨牌能倒下，也就是要证明游戏者手动推倒第一个骨牌，且任意一个骨牌倒下能带动下一个骨牌倒下。又比如，要证明愚公子孙无穷匮，也就是要证明愚公有儿子，愚公任意一代后代，至少有一个儿子。
接下来，我们利用数学归纳法来处理两个真实的数学问题。
【例 1】证明对于任意一个正整数 n，它的 2n 是偶数。
 第一步，当 n=1 时，2n = 2×1 = 2 是偶数。 第二步，假设对于某个正整数 i 而言，2i 是偶数，则 2(i+1)=2i+2。其中 2i 为偶数，2 为偶数，两个偶数之和也是偶数，因此 2(i+1) 也是偶数。  根据数学归纳法可以知道，对于任意一个正整数 n，2n 是偶数，原命题得证。</description>
    </item>
    
    <item>
      <title>13 复杂度：如何利用数学推导对程序进行优化？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/13-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:12 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/13-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/</guid>
      <description>这一讲开始，我们进入到这个专栏“模块三 数据结构与算法”的学习，在这个模块，我们会重点学习数学与算法、代码之间的关系。
在一个程序开发的过程中，常常需要我们去关注程序的复杂度。这一讲，我们就先从复杂度出发，来看看数学的思想是如何应用在程序复杂度优化的。
程序的时间损耗 程序就是计算机执行运算动作的指令，运算就是对数据进行的处理。
例如，1+2 这样的加法运算，就是对两个数据 1 和 2 执行加法的处理。同样地，加法运算还可以针对更多的数据，比如 1+2+3+&amp;hellip;+50，这就是对 1～50 这 50 个数据，执行加法运算的处理。
当我们用计算机指令，也就是程序，执行 1+2 这样的运算时，可能在毫秒，甚至更短的时间内就能得到结果。然而，当数据量变大时，执行的时间就会越来越长。
我们看一个例子，下面一段代码的任务，是给定一个正整数 n，计算从 1～n 之间所有整数之和。
import timeimport syst1 = int(time.time()*1000000)n = int(sys.argv[1])result = 0for i in range(n):result += it2 = int(time.time()*1000000)print t2 - t1我们对代码进行走读：
 第 4 行，记录了程序开始执行的毫秒级时间戳； 第 5 行，得到输入参数 n； 第 7～8 行，执行 1 加到 n 的循环求和； 第 9 行，记录了程序结束计算的毫秒级时间戳； 最后，第 10 行打印出程序执行的时间损耗。  当输入分别是 100、1000 和 10000 时，程序的执行结果如下图所示：</description>
    </item>
    
    <item>
      <title>12 统计学方法：如何证明灰度实验效果不是偶然得到的？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/12-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8E%E7%81%B0%E5%BA%A6%E5%AE%9E%E9%AA%8C%E6%95%88%E6%9E%9C%E4%B8%8D%E6%98%AF%E5%81%B6%E7%84%B6%E5%BE%97%E5%88%B0%E7%9A%84/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:11 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/12-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8E%E7%81%B0%E5%BA%A6%E5%AE%9E%E9%AA%8C%E6%95%88%E6%9E%9C%E4%B8%8D%E6%98%AF%E5%81%B6%E7%84%B6%E5%BE%97%E5%88%B0%E7%9A%84/</guid>
      <description>你好，欢迎来到第 12 课时—— 统计学方法：如何证明灰度实验效果不是偶然得到的？
当你做完 AB 实验，拿着实验结果来论证 v2.0 的系统比 v1.0 的系统效果更好的时候，极有可能有人站出来这样质疑“你的实验结果可信度如何？它是偶然得到的，还是一个必然结果？”
面对这样的质疑，就需要一些统计学的知识了。这一讲，我们就来利用统计学的知识，来论证某个灰度实验的结果的可靠性。
偶然得到的实验结果 大迷糊想通过 AB 实验，来探索用左手掷骰子和用右手掷骰子是否有差异。于是，大迷糊先用左手掷骰子得到点数为 2，再用右手掷骰子得到点数为 6。于是得到结论，右手掷骰子比左手掷骰子点数大 4。
这个结论显然是偶然发生的，是不对的。因为常识和经验都告诉我们，两只手掷骰子点数应该是没有差别的。
然而，工作中使用 AB 实验的场景，很可能是没有这些预先、已知的经验的，这就给实验结果的可靠度判断带来了很多挑战。
例如，上一讲 v2.0 的推荐系统相比 v1.0 的推荐系统，在 CTR 上提高了 0.2pp。这个结果到底是偶然得到的，还是真实存在的呢？这就需要我们具备统计学知识——中心极限定理了。
统计学的圣经——中心极限定理 中心极限定理是统计学中的圣经级定理，它的内容为：假设从均值为 μ，方差为 σ2 的任意一个总体中，抽取样本量为 n 的样本，当 n 充分大时，样本均值x̅的分布近似服从均值为 μ、方差为 σ2/n 的正态分布。通常认为 n≥30 为大样本。
中心极限定理的厉害之处，在于它实现了任意一个分布向正态分布的转换，如下图：
 至于为什么实现了正态分布就很厉害，下文会为你讲解。
 为了更好地理解中心极限定理，我们给出下面的案例。
【例题1】假设某个总体的分布是 1～6 的均匀分布，现在我们利用中心极限定理来估计一下这个总体的均值和方差。
解析：根据中心极限定理，我们需要先计算x̅的均值和方差。为了得到某个随机变量的均值和方差，就要得到尽可能多的x̅的采样点，标记为 x̅i 。对于每个采样点 x̅i，它又是总体的采样点。
因此，我们需要首先对总体进行多次采样，得到一个均值x̅的采样点。再重复这个过程得到多个 x̅i 的值，这样就能计算出x̅的均值和方差了。
具体代码如下：
import randomimport numpy as npxbarlist = []for i in range(1000):xbar = 0for j in range(30):k = random.</description>
    </item>
    
    <item>
      <title>11 灰度实验：如何设计灰度实验并计算实验的收益？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/11-%E7%81%B0%E5%BA%A6%E5%AE%9E%E9%AA%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%81%B0%E5%BA%A6%E5%AE%9E%E9%AA%8C%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C%E7%9A%84%E6%94%B6%E7%9B%8A/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:10 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/11-%E7%81%B0%E5%BA%A6%E5%AE%9E%E9%AA%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%81%B0%E5%BA%A6%E5%AE%9E%E9%AA%8C%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C%E7%9A%84%E6%94%B6%E7%9B%8A/</guid>
      <description>在之前的课时，我们对问题进行了形式化定义，并利用一个很牛的算法进行了最优化求解，之后我们便打造了一个全新的策略优化解决方案。
而接下来，你需要面对的问题，就是证明这个新的解决方案是有效的，是优于之前的解决方案的，而这个证明方法就是做 AB 实验。所以，这一讲我们就来说说 AB 实验的那些事。
灰度实验 在实际的工作中，通常需要进行灰度实验来验证某个新系统相对于旧系统的收益。灰是介于黑和白之间的颜色，可以理解为是个中间态。灰度实验，也可以称作为 AB 实验、灰度发布，名称虽然不同，但本质上是没有什么区别的。
AB 实验的理念，是构造一个平行世界，去观察两个世界的不同。具体来说就是，把线上的流量随机地拆分为具有同样分布的实验组和对照组，然后将新旧两个系统分别作用在这两组流量上，去观察业务指标的变化。
我们举个例子，假设大迷糊负责某个 App 信息流的推荐系统算法的开发。
原本推荐系统的版本号是 v1.0，大迷糊经过对算法和策略的功能迭代，开发了推荐系统 v2.0。接下来，他需要测试 v2.0 相比 v1.0 是否有效果的提升。如果没有提升，则说明开发失败；如果有提升，则开发成功，并可以考虑在线上用 v2.0 来代替 v1.0。
 为了测验证 v2.0 相比 v1.0 是否有效果的提升，大迷糊从数据库里筛出了 N 个用户。 接着，大迷糊通过某个随机算法，把这 N 个用户随机地拆分为人数相等的两组，分别命名为实验组和对照组，每组 N/2 个用户。 下一步，大迷糊用 v2.0 的推荐系统给实验组的 N/2 个用户推荐信息，再用 v1.0 的推荐系统给对照组的 N/2 个用户推荐信息。 经过了几周后，大迷糊分别计算了实验组和对照组用户的业务指标，可能有点击率 CTR、阅读量 PV、UV、用户活跃度等指标。 最终，大迷糊发现，实验组用户的各项指标都优于对照组用户的指标。  这就证明 v2.0 的效果要优于 v1.0 的效果，因此 v2.0 系统成功代替了 v1.0 的系统，并在线上环境中全量生效。
灰度实验的两个关键步骤 虽然，大迷糊全量 v2.0 推荐系统的流程很复杂，但灰度实验本质上只有两个大步骤。
 第一步，分流。即如何获得实验组和对照组的两波流量。 第二步，评估。即用什么指标来分别衡量实验组和对照组的效果。  可以说，这两步将直接决定灰度实验的成败。</description>
    </item>
    
    <item>
      <title>10 信息熵：事件的不确定性如何计算？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/10-%E4%BF%A1%E6%81%AF%E7%86%B5%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:09 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/10-%E4%BF%A1%E6%81%AF%E7%86%B5%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/</guid>
      <description>你好，欢迎来到第 10 课时——信息熵：事件的不确定性如何计算？
从加乘法则开始，我们基于事情的不确定性出发，尝试计算事情发生的可能性。然而，对于事件与事件之间的不确定性如何相比和衡量，单独靠概率就无法说清楚了。我说的这句话是什么意思呢？下面我举个例子来说明。
假设有两场足球赛，也就是两个事件。第一场足球赛，对阵的双方是老挝队和巴西队，标记为事件 A；第二场足球赛，对阵的双方是阿根廷队和葡萄牙队，标记为事件 B。显然，在比赛开始前，这两个事件的比赛结果都具备一定的不确定性。人们也会根据历史数据，分别计算两场足球赛结果的概率。
现在我们思考这样的问题：事件 A 和事件 B 的比赛结果，哪个不确定性更大？
显然是事件 B。因为对于事件 A，除非爆冷，否则巴西队几乎是不可能输给老挝队的，事件 A 比赛结果的不确定性就很低；对于事件 B，阿根廷有梅西，葡萄牙有 C 罗，二者都是球星云集的老牌劲旅，比赛结果的不确定性就非常强。
所以这一讲，我们就来学习如何用一些量化的指标衡量事物的不确定性。
熵 事物的不确定性用“熵”表示。熵越大，则不确定性越强；熵越小，不确定性越小。熵的单位为 bit，所以熵的另一种理解是信息量。
那么什么样的事情的信息量更大呢？一定是对于不确定性事件的结果的信息。
例如，大迷糊向你说，“巴西队 vs 老挝队”的结果是巴西队获胜了，这句话对你而言就是废话，信息量非常少。相反，如果大聪明跟你说，“阿根廷 vs 葡萄牙”的比赛中葡萄牙获胜了，这句话对一个不确定性很强的事件给出了结果，其信息量就很大。
直观来说，越是“废话”，信息量越少；越是描述人们看不明白的事情，信息量就越大。
既然熵可以描述不确定性，那么具体到某个事件身上，熵应该怎么计算呢？我们给出熵的定义式。假设一个事件 A 有 N 个结果，每个结果发生的概率为 pi，那么熵的计算公式为：
我们给一个计算的例子。假设在“巴西队 vs 老挝队”的比赛中，巴西获胜的概率为 0.9，巴西队不胜的概率为 0.1，计算这场比赛的熵。根据定义式计算，可以得出 H(p) = -0.9 * log2 0.9 - 0.1 * log2 0.1 =0.4690。
对于熵的计算，涉及取对数的计算，我们给出下面的代码。
import mathdef entropy(*c):result = 0islegal = 0for x in c:islegal += xresult = result + (-x) * math.</description>
    </item>
    
    <item>
      <title>09 似然估计：如何利用 MLE 对参数进行估计？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/09-%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-mle-%E5%AF%B9%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E4%BC%B0%E8%AE%A1/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:08 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/09-%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-mle-%E5%AF%B9%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E4%BC%B0%E8%AE%A1/</guid>
      <description>你好，欢迎来到第 09 课时——似然估计：如何利用 MLE 对参数进行估计？
前面我们学会了如何计算概率，这一讲我们学习如何利用概率对某个参数进行估计。在读书的时候，你一定接触过极大似然估计，它是数学课程的难点之一，它名字背后的含义，以及它的推导过程都非常复杂，需要你对它有深刻的理解。
不过，有了前面“形式化定义”“概率计算的加乘法则”和求函数最值的“求导法”“梯度下降法”的知识储备，相信极大似然估计也能迎刃而解。
白话理解“极大似然估计” 如果你是刚刚学习概率，极大似然估计这六个字一定会让你产生不解。
似然（Likelihood），可以理解为可能性，也就是概率。举个例子，某个同学毕业于华中科技大学这样的工科院校，那么这位同学是男生的可能性（或者说概率、似然）就更大；相反，某个同学毕业于北京外国语学院这样的文科院校，那么这位同学是女生的可能性（或者说概率、似然）就更大。
那么反过来思考，如果大漂亮是个美丽又可爱的女生，现在有两个候选项：A.大漂亮毕业于华中科技大学；B.大漂亮毕业于北京外国语学院。在对其他信息都毫不知情的情况下，你更愿意相信哪个呢？很显然，相信 B 是更好的选项，因为 B 的概率（或者说似然）更大。
其实，在刚刚的思考逻辑中，我们已经不知不觉地用了极大似然估计的思想了——估计（Estimate），用大白话说就是“猜”。
例如，你对于大漂亮毕业院校的“估计”是她来自北京外国语学院；这就是说，你“猜测”大漂亮毕业于北京外国语学院。那么，为何你猜测她毕业于北京外国语学院，而不是华中科技大学呢？原因就是前者的可能性更大，而后者可能性更小。换句话说，从可能性的视角看，前者是个极大值（Maximum）。
我们将上面思考过程的 3 个关键词“极大（Maximum）”“似然（Likelihood）”“估计（Estimate）”给提炼出来，就得到了极大似然估计这个方法，通常也可以用这 3 个单词的首个字母来表示——MLE。
极大似然估计的方法路径 从刚才的例子不难看出，极大似然估计做的事情，就是通过已知条件对某个未知参数进行估计，它根据观测的样本构建似然函数，再通过让这个函数取得极大值，来完成估计。接着，我们用数学语言来描述整个过程。
极大似然估计的流程可以分为 3 步，分别是似然、极大和估计。
 第一步似然，即根据观测的样本建立似然函数，也是概率函数或可能性函数。 这个步骤的数学表达如下：假设观测的样本或集合为 D，待估计的参数为 θ。则观察到样本集合的概率，就是在参数 θ 条件下，D 发生的条件概率 P(D|θ)。这就是似然函数，也是极大似然估计中最难的一步。 第二步极大，也就是求解似然函数的极大值。 你可以通过求导法、梯度下降法等方式求解。这个步骤的数学表达就简单许多，即 max P(D|θ)。 第三步估计，利用求解出的极大值，对未知参数进行估计。   利用这 3 步就完成了极大似然估计的整个流程。
接下来，我们将这个方法路径用在对“大漂亮毕业院校的极大似然估计表达”上。
 第一步 似然  我们观测的样本结果 D 是“大漂亮是个女生”，待估计的变量 θ 是“大漂亮毕业于哪个学校”。这样，似然函数就是 P(D|θ) = P(大漂亮是个女生|大漂亮毕业于 θ 学校)，其中 θ∈(北京外国语学院,华中科技大学)。
接着，我们还需要了解工科院校、文科院校的男女比例情况，把似然函数写出具体的数字表达。假设华中科技大学的男女比例为 7:1，北京外国语学院的男女比例为 1:8，则有下表的概率值：
 第二步 极大  有了前面的信息，我们就能求解似然函数的极大值了。似然函数中参数 θ 是离散值，只有两个可能的取值。因此，我们既不需要求导法，也不需要梯度下降法，只需要把两种可能性都算一下，再进行比较就可以了。</description>
    </item>
    
    <item>
      <title>08 加乘法则：如何计算复杂事件发生的概率？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/08-%E5%8A%A0%E4%B9%98%E6%B3%95%E5%88%99%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:07 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/08-%E5%8A%A0%E4%B9%98%E6%B3%95%E5%88%99%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>在我们的工作和生活中少不了对概率的计算，对概率的准确计算会帮助我们做出更加合理高效的决策。
例如，早上出门之前，你需要对是否携带雨伞进行决策。如果没有任何依据而随机决策，那么就会遇到下雨没带伞或者晴天带伞的麻烦；而如果有依据，你知道今天下雨的概率超过 80%，那么你就会做出带雨伞的决策，来规避下雨带来不便的风险。
那么问题来了，对于一个事件而言，其发生的概率该如何计算呢？这一讲我们就来解答。
概率来自统计 还记得我们最开始接触概率时的定义吗？概率用来描述一个事件发生的可能性，它是个 0 到 1 的数字。概率的定义式就是 m/n，含义为假设某个现象重复执行 n 次（n 较大），其中目标事件发生了 m 次，则目标事件发生的概率就是 m/n。
 举个例子，一枚硬币重复抛 100 次，其中正面朝上 49 次，反面朝上 51 次，则硬币正面朝上的概率就是 0.49。
 概率的定义式非常重要，如果你能灵活运用，并结合一定的代码开发，有时候可以快速解决一个复杂的数学问题。
我们举个例子，在一个正方形内有一个内切圆，在正方形内随机选取一点，问该点也在圆内的概率是多少？ 这是个数学问题，但你可以借助概率的定义式完成计算，代码如下：
import randomdef main():m = 0n = 1000for _ in range(n):x = random.random()y = random.random()if x*x + y*y &amp;lt; 1:m += 1print 1.0*m/nif __name__ == &#39;__main__&#39;:main()我们对代码进行走读：
 第 4、5 行定义了 m 和 n 两个变量。其中，n 赋值为 1000，意味着我们要重复执行这个动作 1000 次，m 表示坐标点落入圆内的次数； 接下来，就是第 6～10 行的 1000 次实验的循环了。每次实验，我们随机生成一个坐标点 (x,y)，其中 x 和 y 的取值范围都是 0～1 的浮点数； 这样，在第 9 行中，如果点 (x,y) 与原点的距离小于 1，则表示该点在圆内，m 自动加 1； 最后，打印出 m 和 n 的比值。  我们运行程序的结果如下： 这个题目如果从数学的视角来计算，结果就是 P =πr2÷4r2= π÷4 = 0.</description>
    </item>
    
    <item>
      <title>07 线性回归：如何在离散点中寻找数据规律？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/07-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A6%BB%E6%95%A3%E7%82%B9%E4%B8%AD%E5%AF%BB%E6%89%BE%E6%95%B0%E6%8D%AE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:06 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/07-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A6%BB%E6%95%A3%E7%82%B9%E4%B8%AD%E5%AF%BB%E6%89%BE%E6%95%B0%E6%8D%AE%E8%A7%84%E5%BE%8B/</guid>
      <description>经过前面几节课，我们讨论了对问题的形式化定义和对目标函数极值的几种求解方法，以及在大数据多变量环境中对数据计算的方法。
而这一课时，我们就把这些知识用在线性回归上，看一下它们是如何在实际工作中应用的。
假设大漂亮是公司负责增长营销策略的工程师，她利用公司的大数据分析了某件商品的销售情况。她发现这件商品的购买率（购买量除以浏览量）和它的折扣率（折后价除以原价）有着非常强的关系。
因此，她把这件商品最近一周的数据都提取出来，并且以每天一个样本点，尝试分析购买率和折扣率的关系，她的原始数据如下表所示： 我们可以直观看出，折扣率越低，购买率越高。那么除此之外，我们还能分析出其他信息吗？比如，这里的趋势和关系如何用数学语言描述呢？以及可以如何用来指导补贴的投放方法？这些问题就需要用线性回归的知识来分析了。
什么是线性回归？ 回归（也称作拟合），通常是指利用某个函数，尽可能把数据样本点“串”在一起，用于描述输入变量和输出变量间的变化关系。
在回归中最常用的就是线性回归了，这是因为线性回归与人类“越怎样&amp;hellip;越怎样&amp;hellip;”的思维方式更一致。线性回归的特点是，用来把数据“串”起来的那个函数是线性的。线性回归可分为一元线性回归（ 一个自变量）和多元线性回归（至少两个自变量）。
围绕上面的概念，我们尝试写出线性回归的方程。一个线性函数的通式为 y =k·x+b 或者
y =kTx+b。
 其中，x 是 nx1 维的自变量向量，k 是 nx1 维的权重。y 是输出变量，b 是个常数。如果是一元线性回归，则 n 为 1。
 上面两种表达方法殊途同归，区别仅在于形式。前者是把变量当作了向量，通过向量的点乘得到结果；而后者是把向量视作一个特殊的矩阵，通过矩阵的乘法得到结果。
线性回归的目标是，尽可能把数据样本点“串”在一起。也就是说，要求解出 k 和 b，让这个函数尽可能把数据都拟合起来。
接下来，我们以大漂亮遇到的问题为例，试着用线性回归帮帮她。
线性回归的形式化定义 我们先前总结过解决问题的通用方法，包括两步：首先要进行形式化定义，接着对形式化定义的问题进行最优化求解。
形式化定义，是要用数学语言来描述清楚问题的目标是什么。我们前面分析到，问题的目标是尽可能把数据样本点“串”在一起。那么如何用数学语言来描述呢？
在线性回归中，通常用平方误差来衡量拟合的效果。平方误差的定义是，真实值和预测值之差的平方，即 (ŷ-y)2。值得一提的是，我们采用 ŷ 来代表真实值，用 y 来代表回归拟合的预测值。
有了这些背景知识后，我们回到大漂亮的问题。大漂亮想用一个线性函数去拟合购买率和折扣率，不妨用 y 表示购买率，x 表示折扣率，那么线性函数的表达式就是 y = kx + b。
此时，大漂亮面对的是一元线性回归问题，要做的事情就是求解出 k 和 b 的值。假设大漂亮已经有了 k 和 b，那么就能根据输入的 x，拟合出 y 的值了，而线性回归的目标是尽可能让“串”在一起的平方误差最小。因此，平方误差函数在这里的形式就是：
其中求和的 1 到 7，表示的是大漂亮获得的数据集中 7 个样本。公式的含义就是，每个样本的预测值和真实值的平方误差，再求和。大漂亮遇到的问题定性描述是，通过线性回归，让数据尽可能“串”在一起。其形式化定义，就是找到能让平方误差函数最小的 k 和 b 的值。</description>
    </item>
    
    <item>
      <title>06 向量及其导数：计算机如何完成对海量高维度数据计算？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/06-%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E5%AF%BC%E6%95%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%AF%B9%E6%B5%B7%E9%87%8F%E9%AB%98%E7%BB%B4%E5%BA%A6%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:05 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/06-%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E5%AF%BC%E6%95%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%AF%B9%E6%B5%B7%E9%87%8F%E9%AB%98%E7%BB%B4%E5%BA%A6%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/</guid>
      <description>在上一课时，我们学习了利用梯度下降法求解函数的极值。我举了个例子，如果商品利润函数 r 和补贴金额 x 的关系为 r(x) = p(x)×(m - x - c) = (2/(1+e-x) - 1)×(16 - x - 8)，然后我又利用梯度下降法，求解出让利润最大的补贴额 x* 为 2.42 元。
就这个例题而言，其实根本不需要求导法或者是梯度下降法。这是因为，商品定价是 8 元，补贴额 x 的决策空间就是从不打折的 0 元到不要钱的 8 元。如果最小颗粒度是“分”，那么决策空间就是 0.00元～8.00元，这 801 个变量而已。写个 for 循环，对每一个可能的补贴额都简单粗暴地计算一遍，也是一种简单可行的方法。
然而，实际问题中可能会更加复杂。例如，购买概率除了与补贴额有关以外，还跟同行竞争对手的补贴额、商品的有效期、温度、天气、节假日等因素有关。假设有 n 个可能的因素，每个因素的决策空间都是 801 个，那么整体的决策空间就瞬间变成了 801n 个！
此时再用简单粗暴的 for 循环计算就变得不现实了，这也是在大数据环境下，数学算法对复杂业务环境求解计算的优势。
向量是高维度数据的处理单元 我们提到，除了补贴额，影响商品购买率的因素还有很多。为了综合刻画这些因素对购买概率以及利润的影响，自然就需要用多元函数来表达，即 r(x,y,z&amp;hellip;) = r(补贴额，有效期，温度&amp;hellip;)。
 维度  每个影响购买概率的因素，又可称作维度。当维度逐渐变多时，就意味着我们需要在高维度数据空间下处理某个多元函数。在计算机或数学领域中，通常用向量或矩阵来对高维度数据进行计算和表示。
 向量  向量是高维度数据的表现形式，它由多个数字组合在一起，其中每个数字都是某个维度的特征值。通常印刷体用斜体、加粗的小写字母表示，例如 a=[1,2,3,4,5]，而手写时在字母顶上加一小箭头“→”即可。
 矩阵  既然向量是多个数字的组合，同样我们也可以把多个向量组合在一起就得到了矩阵。矩阵通常用斜体、加粗的大写字母表示，例如：
根据向量和矩阵的定义，不难发现向量是一种行数为 1 或列数为 1 的特殊矩阵。有了向量和矩阵，就能把高维度的数据用简单的数学符号表达了。</description>
    </item>
    
    <item>
      <title>05 求极值：如何找到复杂业务的最优解？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/05-%E6%B1%82%E6%9E%81%E5%80%BC%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%9C%80%E4%BC%98%E8%A7%A3/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:04 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/05-%E6%B1%82%E6%9E%81%E5%80%BC%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%9C%80%E4%BC%98%E8%A7%A3/</guid>
      <description>这一讲我将介绍两种求极值的方式，一种是你比较熟悉的求导法，另一种便是更厉害的梯度下降法，这里梯度下降法将与代码结合，去轻松解决非常复杂的业务难题。
想要找到一个复杂业务的最优解，就先需要找到影响这个事情的关键因素，以及关键因素之间的关系，而这个过程就是形式化定义的过程，把问题形式化定义后，再去追逐收益的最大化。
形式化定义 “形式化定义”，就是用函数去表达需要用文字描述的问题。也就是说，在做决策之前，需要把你的动作、收益、风险，用函数建立起联系。
我们举一个实际公司业务的例子。假设你在一个电商公司，负责用户营销红包的投放工作。很明显，对于一件商品，你投放给用户的红包金额越高，用户购买这件商品的可能性越大。然而投放红包的金额越高，利润空间也越小。
那么问题来了，对于一件商品，投放多少金额的红包，能让你的利润最大呢？
要想解决这个问题，就需要先对问题进行形式化定义。假设，用户购买商品的概率与投放的补贴金额的关系为 p(x)。因此，投放金额为 x 的红包额后，商品的利润可以定义为
 r(x) = p(x)×(m - x - c)
 其中，m 为商品的原价，c 为商品的成本价。
有了形式化定义之后，才可以进行业务策略的优化，也就是追逐收益最大化。
追逐收益最大化 “追逐收益最大化”就是求解这个函数的最值，可能是最大值、也可能是最小值。
仍以红包投放为例，要找到能让利润最大的红包金额，你需要用到数学中求解函数极值的知识，也就是计算 max r(x)。
关于某个函数求解极值的问题，我们从中学就开始接触了。那时候我们求解的方法是，令目标函数的一阶导数为零，并求解方程的解，这种方法称作求导法。
【例题1】假设你是某电商公司营销系统的工程师。你们某个商品的购买概率和补贴额的关系为，p(x) = 0.05 x + 0.2。该商品原价 m 为 16 元，成本价 c 为 8 元，求利润最大的补贴额应该是多少？
【解析】商品的利润函数为 r(x) = p(x)×(m - x - c) = (0.05x + 0.2)×(16 - x - 8) = -0.05x2 + 0.2x + 1.6，利用高中的数学求导法，令 r(x) 的导函数为零并解方程，则有：
r&#39;(x) = -0.1x+0.2 = 0</description>
    </item>
    
    <item>
      <title>04 万物可数学，经典公式是如何在生活中应用的？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/04-%E4%B8%87%E7%89%A9%E5%8F%AF%E6%95%B0%E5%AD%A6%E7%BB%8F%E5%85%B8%E5%85%AC%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E5%BA%94%E7%94%A8%E7%9A%84/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:03 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/04-%E4%B8%87%E7%89%A9%E5%8F%AF%E6%95%B0%E5%AD%A6%E7%BB%8F%E5%85%B8%E5%85%AC%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E5%BA%94%E7%94%A8%E7%9A%84/</guid>
      <description>在我们的生活和工作中，有大量的数学应用场景，一些简单的经典公式会在我们的生活中被反复验证、体现。对于经典公式的理解，能增强你的数据 sense，更能帮助你在遇到问题时，迅速找到解决思路。
这一课时我将列举四个脑洞比较大，却又妙趣横生的例子，向你展示数学与万物之间的巧妙联系。
“数学无处不在”，可能学完这一课时，你就会理解为什么说“数学是一切科学之母”了，因为万物、生活、世界的本质就是由数学组成的，或者说可以用数学去解析表达。
正好下周就是双十一了，现在的你一定在各种优惠券和促销规则中与商家斗智斗勇，下面第一个例子我就分别从买家、卖家两个视角，看看这个钱到底应该怎么算？
双十一关于钱的计算 双十一期间，某商家的促销规则是：某笔订单消费满 200 元，可以获得 100 元的代金券，代金券可以在下次消费中使用，下次使用时的规则是，消费满 300 元，直接抵扣 100 元。
那么这样的促销活动规则，折扣率到底是多少呢？
大迷糊认为消费满 200 元获得 100 元代金券，这样折扣率应是 100÷200，就是五折。如果你也是这样认为，那么就中了商家的圈套了。
而大聪明发现为了花出去这个 100 元代金券，需要先消费满 200 元，再第二次消费满 300 元。总账算下来为，商品总价值 500 元，实际花费 400 元，也就是打八折。商家给予的优惠并没有看起来那么多，而就是这样依旧吸引了一批又一批用户“剁手”。
这个例子是以消费者的视角来计算的折扣率，我们还可以从商家的视角来分析商家的投资回报率 ROI（ROI=增量的回报/增量的投入）。一般而言，ROI 的应用场景都跟钱的投资有关，可以定义“回报”为营业额，而“投入”为代金券核销的金额。
现在我们把 ROI 的问题拓展到一个实际的业务场景。假设大漂亮是某宝增长部门的工程师，最近接手的项目是在双十一给用户投放优惠红包。红包的种类有很多，比如满 399 元减 100 元、满 299 元减 50 元、满 199 元减 20 元等等。
在做好了系统开发工作后，大漂亮在用户的维度上，上线了灰度实验。即一半用户被随机地划到了实验组，享受红包优惠；剩下的另一半用户，被划分到了对照组，不享受红包优惠。实验过后的所有数据记录如下表，围绕 GMV（营收额），帮大漂亮算一下这次双十一投放红包的 ROI 吧。 根据 ROI 的定义式很容易得到，ROI=(80万-65万)/10万=1.5。
值得一提的是，如果回报定义为实际的营收额，ROI 一般不会小于 1。因为满减红包这样的投入，是不会被白白浪费的，每一笔投入一定会转化为核销，并计算在营收额中。换句话说，你不花满满减金额，也不会核销掉这 10 元的红包。
简单总结下，如果你负责某个“资源投入换产出”模式下的项目，例如投入补贴换营业额，那么业务指标上涨是显而易见的事情。毕竟对这个系统而言，是有资源投入的。此时，最关键的指标就是资源投入与业务产出的兑换效率，也就是资源的投资回报率 ROI。你的工作方向将会是，在算账体系下的 ROI 提高或优化的工作。
讲完“钱”后，我们再讲下“人”吧。
万有引力与好人缘 以太阳系为例，所有行星都围绕太阳运转，这就说明太阳的引力是最大的；对于一颗流星而言，没有什么天体在围绕它运转，也就是说流星的引力非常小。你可以很形象地认为：太阳的人缘特别好，几乎所有人都围着他转；而流星似乎人缘不太好，它身边几乎没有什么朋友。 形象来看，“人缘”就是一种吸引，就好比物理学的万有引力定律一样，人缘好的人总是能形成自己的一个社交圈，被周围的人认可和关注，并形成一个个像是太阳系、银河系一样的关系网。</description>
    </item>
    
    <item>
      <title>03 用数学决策，如何规划好投入、转化和产出？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/03-%E7%94%A8%E6%95%B0%E5%AD%A6%E5%86%B3%E7%AD%96%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E5%A5%BD%E6%8A%95%E5%85%A5%E8%BD%AC%E5%8C%96%E5%92%8C%E4%BA%A7%E5%87%BA/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:02 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/03-%E7%94%A8%E6%95%B0%E5%AD%A6%E5%86%B3%E7%AD%96%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E5%A5%BD%E6%8A%95%E5%85%A5%E8%BD%AC%E5%8C%96%E5%92%8C%E4%BA%A7%E5%87%BA/</guid>
      <description>在工作和生活中，我们经常会说“这样做，划不划算？”其实这是做每个决策时都会面临的一个问题，也就是心里得有个“小算盘”。
那么怎么我们应该怎么“算账”呢？算完账后又应该如何决策呢？
下面我会先讲一个我的算账定律，带你在麻将局中认识算账的关键三要素：系统、指标、兑换；然后再带你回到学生时代的“补习场景”，认识转化漏斗分析法，看到外部力量向指标的转化路径；最后，还是回归各位程序员的现实工作场景中，通过三个案例看到不同的转化路径，深入理解“投入”“转化”“产出”三者的关系。
本课时的内容梗概如下图所示，可供你参考学习。
公瑾的算账定律 要算账，你需要先明确算账的对象，也就是你在算谁的账。虽然是同一件事情，但对象不一样，可能导致结果的截然不同。
假设你与好友大聪明、大漂亮、大迷糊一起打麻将，4 个小时的激烈斗争后，你们的盈亏账单如下：
假设计算的对象是你，那么会得到总盈亏为 100 元，胜率 40%，平均每局盈利 2 元。如果计算对象是你们四个人，那么会得到总盈亏为 0 元，平均每局盈利 0 元。
你会发现，在整个“麻将局”这一大的系统下，即使每个人的盈亏不同，但整体看这个“系统”的总盈亏情况是 0，也就是不盈不亏。
所以接下来，给你介绍一个算账定律：对于一个没有外部力量作用的系统，它的总账为零。就好比，将你们 4 个人看作一个系统，打麻将只是系统内部的动作，整个系统并没有受到任何来自外部力量的作用，因此总账必然为零，这与物理学中的能量守恒定律很像。
相反，如果一个系统受到了外部力量，那么总账就可能不是零了。 就好比，把你一个人看作一个系统，再把大聪明、大漂亮和大迷糊 3 个人看作是另一个系统，然后在系统和系统间的相互作用下。最后，你的系统盈利了 100 元，而另一个 3 人合体的系统亏损了 100 元。
关键要素：系统、指标和兑换 利用算账定律时，你需要把握好以下几个关键要素，分别是系统、指标和兑换。我们以大漂亮的学习成绩为例展开讨论。
系统，就是一个个对象，它包括了你研究的目标对象，也包括了影响你研究目标的外部系统。对于大漂亮的学习而言，大漂亮就是一个系统，老师也是一个系统。
指标，是评价系统运转结果的数学变量，即总账。例如，对于大漂亮的系统而言，指标包括但不限于考试成绩、生活愉悦度、日均自习时长、日均参加补习班的时长、日均娱乐时长等。
兑换，是个动作，也是个结果，即你在用什么来换取什么。算账定律（算账版的能量守恒定律）说到，对于一个没有外部力量作用的系统，它的总账为零；反过来说，要想指标（总账）有提高，就需要借助外部力量，并把它兑换为指标的提高。
我们以大漂亮想要提升考试成绩为例，通过两种方式来看看系统情况：
 第一种方式是去参加补习班。此时，大漂亮是一个系统，补习班老师是另一个系统。大漂亮系统，在借助补习班老师系统的外部作用，来兑换出考试成绩的提高。 而另一个方式是减少娱乐时长，用来增加自习时长。此时大漂亮系统没有接收外力，那么总账还是零吗？依然是。大漂亮成绩提高了，但是娱乐时间变少，导致生活愉悦度下降，这是一种系统内部的兑换。  对这个大漂亮的例子，我们可以得出以下结论：
 在外部力量改变的时候（例如，从参加大糊涂补习班，更改为参加小天才补习班），会让系统的总账变好。即生活愉悦度不折损的基础上，提高学习成绩。 在外部力量不改变的时候，系统总账不变，但可以通过系统内部兑换，提高某个指标。即减少娱乐时长，增加自习时长。通过降低生活愉悦度，兑换出学习成绩的提高。对于大漂亮而言，有得有失，总账不变。  这两种方式的结论分别如下图所示：
转化漏斗分析法 从上面“打麻将”和“大漂亮提升成绩”的例子，你会发现纯内部力量的调整，只是左手倒右手的兑换，而让指标变得更好的方式是，要借助外部力量。
有了外部力量之后，就要开始分析外部力量作用在系统中的效率，这就需要转化漏斗分析法。
 转化，是一个动作，表示的是外部力量转化为指标提高的动作过程。 漏斗，代表了效率，即转化过程的投入和产出分别是多少。  转化漏斗分析，能够辅助你看清转化路径，并寻找瓶颈予以突破。
我们继续以大漂亮参加补习班为例。假设大漂亮每天参加 3 个小时的补习班学习，最终学习成绩获得了 10 分的提高。那么问题来了，这 3 小时的补习转化为 10 分的提高，转化路径是什么？转化效率如何？是否还有提高的空间呢？
带着这些问题，我们通过对大漂亮学习的无死角跟踪。我们发现，补习时长转化为分数提高的路径为：
 投入补习的时间，可以拆分为认真听课的时间，和不认真听课（玩手机、打瞌睡）的时间。 认真听课的时间里，会带来掌握知识点的提高。 掌握的知识点，会换取考试成绩的提高。  根据转化路径，我们就能计算出转化效率。下表是大漂亮的转化效率表：</description>
    </item>
    
    <item>
      <title>02 逻辑与沟通，怎样才能讲出有逻辑的话？</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/02-%E9%80%BB%E8%BE%91%E4%B8%8E%E6%B2%9F%E9%80%9A%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E8%AE%B2%E5%87%BA%E6%9C%89%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%9D/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:01 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/02-%E9%80%BB%E8%BE%91%E4%B8%8E%E6%B2%9F%E9%80%9A%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E8%AE%B2%E5%87%BA%E6%9C%89%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%9D/</guid>
      <description>你好，欢迎来到第 02 课时—— “与”“或”“非”：怎样才能讲出有逻辑的话？
我们都知道，语言沟通的背后是说话人逻辑思维的过程，单句与单句间、事件与事件间，都是靠关联词联系起来的，所以这节课我将从数学逻辑的角度，向你论述语言沟通背后的原理。
我将先向你介绍这一课时的根本思维原则 —— MECE 原则，再从“与”“或”“非”“异或”，以及“文氏图”这些运算方式出发，带你深入剖析沟通表达中的关联词。
从日常沟通看逻辑 在日常的沟通中，代表逻辑关系的词汇有很多，例如“而且”“或者”“但是”“如果&amp;hellip;那么&amp;hellip;”“因为&amp;hellip;所以&amp;hellip;”等关联词。
在我们使用这些词汇的时候，其实都是在表达事件之间的逻辑关系，如果你的逻辑是混乱的或者是不清晰的，就会出现关联词乱用的情况，从而造成沟通效率低下，甚至传递错误信息。
我们先来看一个例子，事情背景是某个系统需要从 A 环境迁移过渡至 B 环境，大家可以注意一下这段话有什么表达不妥之处。
 “为了保证系统的稳定过渡，并且保证在过渡期，各个使用方的需求正常迭代，因此系统拟定共分为三期：过渡期、实验期、切换期。其中，过渡期采用某技术，保证数据系统打通；实验期通过 AB 实验，验证流程正确。”
 从字面来看，我们能脑补出说话者要做什么事情，以及做这些事情的目的和方法。但是，从逻辑的视角来看，上面一段话至少包含了以下几个问题：
 “保证系统的稳定过渡”和“在过渡期内，各个使用方的需求正常迭代”，这二者的语意是包含关系，并不是并列关系，用 “并且” 进行连接，不合理。 为了保证系统的稳定过渡，因此需要分为三期。这里构不成因果关系，用 “因此” 进行连接，不合理。 过渡期怎样怎样，实验期怎样怎样，切换期呢？丢了一个重要环节，不知道需要做什么事情。  这些问题看似是语文问题，实际是背后思考的逻辑问题。
而逻辑思维对于程序员的代码编程能力非常重要，所以接下来我将向你介绍“MECE 原则”，帮你提升逻辑能力，MECE 原则非常重要，它将贯穿整个课时内容。
MECE 原则，提升逻辑思维水平 MECE 原则（Mutually Exclusive Collectively Exhaustive）的中文意思是“相互独立，完全穷尽”，简而言之，能够做到不重叠、不遗漏，兼顾排他性和完整性。
 MECE 原则是麦肯锡提出的一种结构化思考方式，无论是报告撰写，提案演讲，业务分析，它是一种很好的思维方式。
 它就像是切比萨一样，一个大比萨，用 4 刀切成了 8 份，每一份之间彼此不重叠（排他）；所有的小比萨不遗漏（完整）地合在一起，又还原了大比萨。
我们来看个例子，公园的票价问题。公园的门票价格是 20 元，优惠票包括了老人票和儿童票。价格制度为：
 不到 10 岁的儿童免费； 10 岁以上的未成年人半价； 60 岁及以上的老人免费； 其他成年人无折扣。  我们用 MECE 原则来看一下这里的定价制度，就会发现这个制度不满足“不遗漏”“不重叠”的要求。比如，这让 10 岁的小琳很尴尬，她到底是算不到 10 岁免费呢？还是 10 岁以上未成年的半价呢？至少，从上面的描述是看不出来的。</description>
    </item>
    
    <item>
      <title>01 从计数开始，程序员必知必会的数制转换法</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/01-%E4%BB%8E%E8%AE%A1%E6%95%B0%E5%BC%80%E5%A7%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%B3%95/</link>
      <pubDate>Wed, 22 Dec 2021 01:50:00 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/01-%E4%BB%8E%E8%AE%A1%E6%95%B0%E5%BC%80%E5%A7%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%B3%95/</guid>
      <description>以前看过一个幽默段子，老师说：“世界上有 10 种人，一种懂二进制，另一种不懂二进制。”小琳问：“那另外 8 种人呢？” 显然小琳同学是不懂二进制的那类人。二进制的 10，代表的是十进制的 2。替换到老师的话中就是，世界上有两种人，一种懂二进制，另一种不懂二进制。
当我们还是个孩童时，幼儿园的阿姨便用火柴棍教我们如何数数。这是最早期的数学教育，这也是在某个数制下的计数问题。
作为第一节课，我还是想和你回归最基本的“数制转换”主题。我将以图文结合的方式，与你一起回顾温习数制，详解不同数制之间的巧妙联系，并重新思考数制与编程、计算机的关联。例如，如何利用二进制的位运算，对一个查找问题的代码进行优化等内容。
数制 数制是一种计算数量大小的制度，也是计数法。用大白话来说，就是数数的方法。
数制中，最重要的因素是基数。假设我们设置基数为 10 来数数，那就是在用十进制计数法；如果设置基数为 2，就是在用二进制计数法。
不同的数制中，使用最广泛的就是十进制，这与人类有 10 个手指头是密不可分的。人类在学习计数和四则运算时，会通过手指头辅助计算。
 在我国的古代，也曾经使用过十六进制。例如，成语半斤八两的含义是彼此不相上下，实力相当。即半斤就是 8 两，1 斤就是 16 两。 在时间的计数场景时，我们也用过二十四进制和六十进制。例如，1 天等于 24 小时，1 小时等于 60 分钟，1 分钟等于 60 秒。  不同数制的表达 有了不同的数制，就需要对数制下的数字进行区分，否则就会造成混淆。例如，象征考试得了满分的 100，在十进制下依旧是 100；而在二进制下，它就是十进制下的 4；在八进制，则表示十进制下的 64；在十六进制，则表示十进制下的 256。
 至于为什么如此计算转换，下文的数制转换方法会详细讲解。
 所以如果对数字不加以说明，你会发现很难判断这到底是哪个数制下的数字，毕竟同一数字在不同数制下其意义是完全不同的。为了避免混淆，我们对不同数制下的数字做了区分。
十进制使用的数字符号是 [0,1,2,3,4,5,6,7,8,9]；对于二进制和八进制，它们仍然沿用十进制的数字符号。在十六进制中，由于数字符号不够用，这就需要额外补充。一般用 [A,B,C,D,E,F]（一般不会特别区分字母的大小写），分别代表十进制下的 [10,11,12,13,14,15]。
 一般而言，没有额外说明的数字都是十进制下的数字； 表示二进制时，会用 0b 作为数字的前缀； 表示八进制时，会用 0o 或者 0 作为数字的前缀； 表示十六进制时，会用 0x 作为数字的前缀。  这里 b、o、x 三个英文字母的选择均来自数制的英文单词。
综上，我们对这几个数制的信息整理如下表：</description>
    </item>
    
    <item>
      <title>00 开篇词 数学，编程能力的营养根基</title>
      <link>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/00-%E5%BC%80%E7%AF%87%E8%AF%8D-%E6%95%B0%E5%AD%A6%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E7%9A%84%E8%90%A5%E5%85%BB%E6%A0%B9%E5%9F%BA/</link>
      <pubDate>Wed, 22 Dec 2021 01:49:59 +0800</pubDate>
      
      <guid>http://yipsen.github.io/documents/columns/math/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BE/00-%E5%BC%80%E7%AF%87%E8%AF%8D-%E6%95%B0%E5%AD%A6%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E7%9A%84%E8%90%A5%E5%85%BB%E6%A0%B9%E5%9F%BA/</guid>
      <description>你好，我是公瑾，欢迎来到《程序员的数学课》。一些同学可能知道，之前我在拉勾教育就开设了一个[《数据结构与算法》]课程，目的是帮助大家提升编码能力，打牢代码基础，在结课时也受到许多同学的好评，表示所讲的内容在面试和工作中都很有实用性。
编程一类的基础能力固然重要，但这些依旧不是程序员全部的“立足之本”。个人角度而言，从我在中科院的博士研究生经历，再到后来从事机器学习、数据挖掘等算法研发工作，都是数学作为我的基础思维能力支撑我一路走来。
程序员为什么要注重数学？ 在[《数据结构与算法》]课程中，许多留言问题高频集中在：复杂度如何计算、某个代码优化是否降低了时间复杂度，或者是动态规划的状态转移方程问题，等等。这的确是在学习数据结构中遇到的困难，但剥离了外壳之后，你会发现本质上都是数学问题。
举个例子，对于一个有序数组中查找目标值的问题，应该采用二分查找算法。而且随着数组元素越来越多，二分查找相对全局遍历而言，性能上的优势会越来越明显。从数学视角来看，这是因为当 x 很大时，lnx &amp;laquo;x。比如 x=100，ln100=4.6 &amp;laquo; 100。
y=lnx 与 y=x 的函数图
可能许多同学知道二分查找效率更高，但二分查找的代码，是需要采用递归进行实现的。很多同学为了实现方便，就会考虑采用暴力搜索的查找方式，也就是一个 for 循环搞定。但如果你知道了它背后的数学原理，并且深刻体会到 ln100=4.6 &amp;laquo; 100，你就再也不会用 for 循环去实现有序数组的查找问题了。
此外，数学还可以帮助你降低代码的复杂度。
我们看一个编程问题。一个数组中，只有数字 obj 出现了一次，其他数字都出现了两次。请查找出 obj，约束为 O(n) 的时间复杂度、O(1) 的空间复杂度。
例如在数组 a = [2,1,4,3,4,2,3] 中，则输出 1。因为 2、3、4 都出现了两次，唯独 1 只出现一次。
这是个在无序数组中，涉及与其他元素匹配的查找问题。常规解法的复杂度应该是：O(n²) 时间复杂度、O(1) 空间复杂度，或者 O(n) 时间复杂度、O(n) 空间复杂度。显然，这并不符合题目的约束。
要想解决这个问题，需要借助数学的异或运算。异或有这样两个性质：第一，任何数异或自己为零；第二，任何数异或零，是它自己。借助异或运算，你只需要把数组 a 中所有元素计算一下异或就可以得到 obj 了。实现起来，就是如下所示的 O(n) 时间复杂度的 for 循环，且不需要额外开辟复杂变量。
a = [2,1,4,3,4,2,3]result = a[0]for i in range(1,len(a)):result = result ^ a[i]print result从上面的例子中你便能认识到数学的重要性，越是优雅的程序，越是能用简单的代码实现同样的需求。</description>
    </item>
    
  </channel>
</rss>
