<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on Yipsen Ye</title>
    <link>http://localhost:8080/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on Yipsen Ye</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 06 Feb 2022 16:31:43 +0000</lastBuildDate>
    <atom:link href="http://localhost:8080/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>创建型 - 单例模式</title>
      <link>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</link>
      <pubDate>Sun, 06 Feb 2022 16:31:43 +0000</pubDate>
      <guid>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</guid>
      <description>&lt;p&gt;单例模式（Singleton Pattern）属于创建类型的一种常用的软件设计模式。&lt;/p&gt;&#xA;&lt;p&gt;单例对象保证全局（或指定上下文中，如进程，线程内唯一）仅有一个实例存在，并提供一个该唯一实例的访问点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要单例模式&#34;&gt;为什么需要单例模式&lt;/h2&gt;&#xA;&lt;p&gt;打井喝水，并不是每个人想喝水就要打一口井。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优点：在内存里只有一个实例，所以能够节约系统资源，减少了内存的开销，尤其是频繁的创建和销毁实例，可以提高系统效率，同时也能够严格控制客户对它的访问。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;缺点：也正是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，这样扩展起来有一定的困难。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;优点即缺点，所以更应该说是特点，在特定场景下使用。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;常见应用场景&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;spring bean&lt;/li&gt;&#xA;&lt;li&gt;数据库连接&lt;/li&gt;&#xA;&lt;li&gt;需要频繁的进行创建和销毁的对象&lt;/li&gt;&#xA;&lt;li&gt;创建对象时耗时过多或耗费资源过多(重量级对象)&lt;/li&gt;&#xA;&lt;li&gt;经常用到的对象、工具类对象、频繁访问数据库或文件的对象(数据源、session工厂)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;classDiagram&#xD;&#xA;    class Singleton {&#xD;&#xA;        -Singleton instance&#xD;&#xA;        -Singleton()&#xD;&#xA;        +static getInstance() Singleton&#xD;&#xA;    }&#xD;&#xA;    Singleton --o Singleton&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;&#xA;&lt;p&gt;要实现单例模式，关键有 3 个要素：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;单例类只有一个实例对象；如&lt;code&gt;instance&lt;/code&gt;；此为单例模式的核心要素。&lt;/li&gt;&#xA;&lt;li&gt;该单例对象必须由单例类自行创建；一般情况下会将构造函数声明为私有的，如&lt;code&gt;private Singleton()&lt;/code&gt;；这样外部无法实例化，也无法被继承，此举为保证唯一性，从而避免勿用。&lt;/li&gt;&#xA;&lt;li&gt;单例类对外提供一个访问该单例的全局访问点；如&lt;code&gt;getInstance()&lt;/code&gt;；由于已阻止外部构建，即单例类是一个只读类，外部不能创建或修改，需提供一个读取接口。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;即为了避免城市被私人挖得千疮百孔，没收公众的挖井工具，收归专门管理，但开放水利给公众使用。&lt;/p&gt;&#xA;&lt;p&gt;具体常用的几种实现方法：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-饿汉式&#34;&gt;1. 饿汉式&lt;/h3&gt;&#xA;&lt;p&gt;饿汉式顾名思义就是把食物（对象）提前做好，需要时直接拿取即可使用（吃掉）。简而言之即&lt;code&gt;预先构建&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 饿汉式单例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Eager&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 提前把对象实例化，此对象实例全局唯一&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Eager instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Eager();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 私有化构造器，不允许外部使用，以免破坏唯一性&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Eager&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;singleton have been created&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 提供唯一访问点&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Eager &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 功能特性&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;eatSomething&lt;/span&gt;(String something) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; something &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; eat&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 测试代码&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;testEager&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// TODO: make it multithread&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assertEquals(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cake eat&amp;#34;&lt;/span&gt;, Eager.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;eatSomething&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cake&amp;#34;&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;饿汉式是最省心的一种方案，其缺点就是占用资源，因为实例是提前创建的而不是按需，因此就算对象不被使用也会一直占据内存空间，其在启动时就需要耗时进行构建。&lt;/p&gt;</description>
    </item>
    <item>
      <title>结构型 - 代理模式</title>
      <link>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</link>
      <pubDate>Sun, 06 Feb 2022 16:31:43 +0000</pubDate>
      <guid>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</guid>
      <description>&lt;p&gt;代理在软件设计中是一种非常常见的设计思路，&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要代理模式&#34;&gt;为什么需要代理模式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;常见应用场景&#34;&gt;常见应用场景&lt;/h3&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;&#xA;&lt;p&gt;代理模式实现上有静态代理与动态代理之分。而动态代理又有JDK自带的实现方案，也有CGLib等第三方工具的实现方案，效果各有不同。&lt;/p&gt;&#xA;&lt;p&gt;一、静态代理&lt;/p&gt;&#xA;&lt;p&gt;二、动态代理（JDK实现方案）&lt;/p&gt;&#xA;&lt;p&gt;三、动态代理（CGLib实现方案）&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用案例&#34;&gt;使用案例&lt;/h2&gt;&#xA;&lt;p&gt;// 待补充实际工作上项目的使用案例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;引申&#34;&gt;引申&lt;/h2&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;</description>
    </item>
    <item>
      <title>行为型 - 观察者模式</title>
      <link>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</link>
      <pubDate>Sun, 06 Feb 2022 16:31:43 +0000</pubDate>
      <guid>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</guid>
      <description>&lt;p&gt;观察者模式（Observer Pattern）属于行为类型的一种常用的软件设计模式。还有其他的称谓如，发布-订阅模式，模型-视图模式，而最常见的应用就是事件-通知机制了。&lt;/p&gt;&#xA;&lt;p&gt;该模式定义了一种一对多的依赖关系，并对关系进行解耦。即一个对象发生变化时，将通知所有依赖他的对象，以进一步处理相应变化。通过变化产生事件，进而通知处理相应变化的方式，实现了两个对象的解耦，并提供了灵活的依赖关系。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要观察者模式&#34;&gt;为什么需要观察者模式&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解耦&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;常见应用场景&#34;&gt;常见应用场景&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;spring event&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;classDiagram&#xD;&#xA;    class Subject {&#xD;&#xA;        &amp;lt;&amp;lt;abstract&amp;gt;&amp;gt;&#xD;&#xA;        +observers&#xD;&#xA;        +addObserver()&#xD;&#xA;        +removeObserver()&#xD;&#xA;        +notifyObserver()&#xD;&#xA;    }&#xD;&#xA;    class Observer {&#xD;&#xA;        &amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&#xD;&#xA;        update()&#xD;&#xA;    }&#xD;&#xA;    class ConcreteSubject {&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;    class ContreteObserver {&#xD;&#xA;&#xD;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;&#xA;&lt;p&gt;要实现观察者模式，其关键有 4 个对象，分别是：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;对象&lt;/th&gt;&#xA;          &lt;th&gt;称谓&lt;/th&gt;&#xA;          &lt;th&gt;特性&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Subject&lt;/td&gt;&#xA;          &lt;td&gt;被观察者&lt;/td&gt;&#xA;          &lt;td&gt;被观察者提供一系列方法以维护观察者列表（可随时进行增删），同时定义通知方法，以在发生变化时通知已维护在列表中的观察者们。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ConcreteSubject&lt;/td&gt;&#xA;          &lt;td&gt;具体的被观察者&lt;/td&gt;&#xA;          &lt;td&gt;被观察者的具体实现类，实现具体场景下发送变化通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Observer&lt;/td&gt;&#xA;          &lt;td&gt;观察者&lt;/td&gt;&#xA;          &lt;td&gt;观察者可以是一个或多个，当被观察者Subject发生变化时，观察者将收到通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ConcreteObserver&lt;/td&gt;&#xA;          &lt;td&gt;具体的观察者&lt;/td&gt;&#xA;          &lt;td&gt;观察者的具体实现类，不同的观察者在收到通知后可实现不同的操作。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;1-基础方式&#34;&gt;1. 基础方式&lt;/h3&gt;&#xA;&lt;p&gt;观察者模式实现如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;定义被观察者&lt;/p&gt;&#xA;&lt;p&gt;关键定义三个特性：添加观察者，移除观察者，通知观察者。其中通知观察者可由具体实现类按需在具体场景下处理发送逻辑。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Subject&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Observer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; observers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addObserver&lt;/span&gt;(Observer observer) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        observers.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(observer);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeObserver&lt;/span&gt;(Observer observer) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        observers.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(observer);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;notifyObserver&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;被观察者的具体实现类&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
