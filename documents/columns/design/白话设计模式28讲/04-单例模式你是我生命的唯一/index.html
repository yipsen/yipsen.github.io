<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<meta name="X-UA-Compatible" , content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<link rel="icon" type="image/png" href="/%20/favicon.png">

<title>04 单例模式：你是我生命的唯一 | Yipsen Ye</title>
<meta name="description" content="【故事剧情】
 爱情是每一个都渴望的，Tony 也是一样！自从毕业后，Tony 就一直没再谈过恋爱，离上一次的初恋也已经过去两年。一个巧合的机会，Tony 终于遇上了自己的喜欢的人，她叫 Jenny，有一头长发，天生爱笑、声音甜美、性格温和……
作为一个程序员的 Tony，直男癌的症状也很明显：天生木讷、不善言辞。Tony 自然不敢正面表白，但他也有自己的方式，以一种传统书信的方式，展开了一场暗流涌动的追求……经历了一次次屡战屡败，屡败屡战的追求之后，Tony 和 Jenny 终于在一起了！
然而好景不太长，由于种种的原因，最后 Jenny 还是和 Tony 分开了……
人生就像一种旅行，蜿蜒曲折，一路向前！沿途你会看到许多的风景，也会经历很多的黑夜，但我们无法回头！有一些风景可能很短暂，而有一些风景我们希望能够伴随自己走完余生。Tony 经历过一次被爱，也经历过一次追爱；他希望下次能找到一个可陪伴自己走完余生的她，也是他的唯一！
 用程序来模拟生活 相信每一个人都渴望有一个纯洁的爱情，希望找到唯一的她。不管你是单身狗一个，还是已经成双成对，肯定都希望你的伴侣是唯一的！程序如人生，程序也一样，有一些类你希望它只有一个实例。
我们用程序来模拟一个真爱。
源码示例：
class MyBeautifulGril(object):&amp;quot;&amp;quot;&amp;quot;我的漂亮女神&amp;quot;&amp;quot;&amp;quot;__instance = None__isFirstInit = Falsedef __new__(cls, name):if not cls.__instance:MyBeautifulGril.__instance = super().__new__(cls)return cls.__instancedef __init__(self, name):if not self.__isFirstInit:self.__name = nameprint(&amp;quot;遇见&amp;quot; &#43; name &#43; &amp;quot;，我一见钟情！&amp;quot;)MyBeautifulGril.__isFirstInit = Trueelse:print(&amp;quot;遇见&amp;quot; &#43; name &#43; &amp;quot;，我置若罔闻！&amp;quot;)def showMyHeart(self):print(self.">
<meta name="author"
  content="">

<link rel="stylesheet" type="text/css" href="/css/main.css">

</head>

<body>
    <header>
        <div class="logo-link" style="width: 60px; color: #CA6924;">
    <a href="http://yipsen.github.io/">
        <img style="margin-bottom: -1rem;" src="/image/deer.svg" alt="logo">
        <span style="font-size: 0.5rem; color: #CA6924;">Yipsen Ye</span>
    </a>
</div>
<nav class="navbar justify-content-end">
    <ul class="nav-list">
        
        
        <li class="nav-item">
            <a class="nav-link"
                href="http://yipsen.github.io/posts/">札记</a>
        </li>
        
        <li class="nav-item">
            <a class="nav-link"
                href="http://yipsen.github.io/collections/">图集</a>
        </li>
        
        <li class="nav-item">
            <a class="nav-link"
                href="http://yipsen.github.io/about/">关于</a>
        </li>
        
    </ul>
</nav>
    </header>
    <main id="content">
        
<div class="container">
    <article class="post-block">
        <h1 class="post-title">04 单例模式：你是我生命的唯一</h1>
        <div class="post-info">
            <div>2021-12-22|<a class="post-tag" href="/tags/design/">design</a></div><div class="post-category">
                
                <a href="/categories/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/"> 白话设计模式28讲 </a>
                
            </div></div>
        <div class="post-content">
            <p>【故事剧情】</p>
<blockquote>
<p>爱情是每一个都渴望的，Tony 也是一样！自从毕业后，Tony 就一直没再谈过恋爱，离上一次的初恋也已经过去两年。一个巧合的机会，Tony 终于遇上了自己的喜欢的人，她叫 Jenny，有一头长发，天生爱笑、声音甜美、性格温和……</p>
<p>作为一个程序员的 Tony，直男癌的症状也很明显：天生木讷、不善言辞。Tony 自然不敢正面表白，但他也有自己的方式，以一种传统书信的方式，展开了一场暗流涌动的追求……经历了一次次屡战屡败，屡败屡战的追求之后，Tony 和 Jenny 终于在一起了！</p>
<p>然而好景不太长，由于种种的原因，最后 Jenny 还是和 Tony 分开了……</p>
<p>人生就像一种旅行，蜿蜒曲折，一路向前！沿途你会看到许多的风景，也会经历很多的黑夜，但我们无法回头！有一些风景可能很短暂，而有一些风景我们希望能够伴随自己走完余生。Tony 经历过一次被爱，也经历过一次追爱；他希望下次能找到一个可陪伴自己走完余生的她，也是<strong>他的唯一！</strong></p>
</blockquote>
<p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2028%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/assets/b6726f60-c390-11e8-b5ca-0da8fdb41124.jpg" alt="img"></p>
<h3 id="用程序来模拟生活">用程序来模拟生活</h3>
<p>相信每一个人都渴望有一个纯洁的爱情，希望找到唯一的她。不管你是单身狗一个，还是已经成双成对，肯定都希望你的伴侣是唯一的！程序如人生，程序也一样，有一些类你希望它只有一个实例。</p>
<p>我们用程序来模拟一个真爱。</p>
<p>源码示例：</p>
<pre tabindex="0"><code>class MyBeautifulGril(object):
    &quot;&quot;&quot;我的漂亮女神&quot;&quot;&quot;
    __instance = None
    __isFirstInit = False

    def __new__(cls, name):
        if not cls.__instance:
            MyBeautifulGril.__instance = super().__new__(cls)
        return cls.__instance

    def __init__(self, name):
        if not self.__isFirstInit:
            self.__name = name
            print(&quot;遇见&quot; + name + &quot;，我一见钟情！&quot;)
            MyBeautifulGril.__isFirstInit = True
        else:
            print(&quot;遇见&quot; + name + &quot;，我置若罔闻！&quot;)

    def showMyHeart(self):
        print(self.__name + &quot;就我心中的唯一！&quot;)

</code></pre><p>测试代码：</p>
<pre tabindex="0"><code>def TestLove():
    jenny = MyBeautifulGril(&quot;Jenny&quot;)
    jenny.showMyHeart()
    kimi = MyBeautifulGril(&quot;Kimi&quot;)
    kimi.showMyHeart()
    print(&quot;id(jenny):&quot;, id(jenny), &quot; id(kimi):&quot;, id(kimi))

</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>遇见Jenny，我一见钟情！
Jenny就我心中的唯一！
遇见Kimi，我置若罔闻！
Jenny就我心中的唯一！
id(jenny): 47127888  id(kimi): 47127888

</code></pre><p>看到了没，一旦你初次选定了 Jenny，不管换几个女人，你心中念叨的还是 Jenny！这才是真爱啊！哈哈……</p>
<h3 id="从剧情中思考单例模式">从剧情中思考单例模式</h3>
<h4 id="单例模式">单例模式</h4>
<blockquote>
<p>Ensure a class has only one instance, and provide a global point of access to it.</p>
<p>确保一个类只有一个实例，并且提供一个访问它的全局方法。</p>
</blockquote>
<h4 id="设计思想">设计思想</h4>
<p>有一些人，你希望是唯一的，程序也一样，有一些类，你希望实例是唯一的。<strong>单例</strong>就是一个类只能有一个对象（实例），单例就是用来控制某些事物只允许有一个个体，比如在我们生活的世界中，有生命的星球只有一个——地球（至少到目前为止人类所发现的世界中是这样的）。</p>
<p>人如果脚踏两只船，你的生活将会翻船！程序中的部分关键类如果有多个实例，将容易使逻辑混乱，程序崩溃！</p>
<h3 id="单例模式的模型抽象">单例模式的模型抽象</h3>
<h4 id="代码框架">代码框架</h4>
<p>单例的实现方式有很多种，下面列出几种常见的方式。</p>
<h5 id="1-重写-_new_-和-_init_-方法"><strong>1. 重写 <em>new</em> 和 <em>init</em> 方法</strong></h5>
<p>源码示例：</p>
<pre tabindex="0"><code>class Singleton1(object):
    &quot;&quot;&quot;单例实现方式一&quot;&quot;&quot;
    __instance = None
    __isFirstInit = False

    def __new__(cls, name):
        if not cls.__instance:
            Singleton1.__instance = super().__new__(cls)
        return cls.__instance

    def __init__(self, name):
        if not self.__isFirstInit:
            self.__name = name
            Singleton1.__isFirstInit = True

    def getName(self):
        return self.__name

# Test
tony = Singleton1(&quot;Tony&quot;)
karry = Singleton1(&quot;Karry&quot;)
print(tony.getName(), karry.getName())
print(&quot;id(tony):&quot;, id(tony), &quot;id(karry):&quot;, id(karry))
print(&quot;tony == karry:&quot;, tony == karry)

</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>Tony Tony
id(tony): 46050320 id(karry): 46050320
tony == karry: True

</code></pre><p>在 Python 3 的类中，<em>*new</em>* 负责对象的创建，而 <em>*init</em>* 负责对象的初始化；<em>*new</em>* 是一个类方法，而 <em>*init</em>* 是一个对象方法。</p>
<p><em>*new</em>* 是我们通过类名进行实例化对象时自动调用的，<em>*init</em>* 是在每一次实例化对象之后调用的，<em>*new</em>* 方法创建一个实例之后返回这个实例对象，并将其传递给 <em>*init</em>* 方法的 self 参数。</p>
<p>在上面的示例代码中，我们定义了一个静态的 <em>*instance</em>* 类变量，用来存放 Singleton1 的对象，<em>*new</em>* 方法每次返回同一个_<em>instance对象_</em>（若未初始化，则进行初始化）。因为每一次通过 s = Singleton1() 的方式创建对象时，都会自动调用 <em>*init</em>* 方法来初始化实例对象；因此 <em>*isFirstInit</em>* 的作用就是确保只对 <em>*instance</em>* 对象进行一次初始化，故事剧情中的代码就是用这种方式实现的单例。</p>
<p>在 Java 和 C++ 这种静态语言中，实现单例模式的一个最简单的方法就是：将构造函数声明成 private，再定义一个 getInstance() 的静态方法返回一个对象，并确保 getInstance() 每次返回同一个对象即可，如下面的 Java 示例代码。</p>
<pre tabindex="0"><code>/**
 * Java中单例模式的实现，未考虑线程安全
 */
public class Singleton {
    private static Singleton instance = null;

    private String name;

    private Singleton(String name) {
        this.name = name;
    }

    public static Singleton getInstance(String name) {
        if (instance == null) {
            instance = new Singleton(name);
        }
        return instance;
    }
}

</code></pre><p>Python 中 <em>*new</em>* 和 <em>*init</em>* 都是 public 的，所以我们需要通过重写 <em>*new</em>* 和 <em>*init</em>* 方法来改造对象的创建过来，从而实现单例模式。如果你要更详细地了解 Python 中 <em>*new</em>* 和 <em>*init</em>* 的原理和用法，请参见《<a href="https://blog.csdn.net/luoweifu/article/details/82732313">深入理解 Python 中的 <strong>new</strong> 和 <strong>init</strong></a>》。</p>
<h5 id="2-自定义-metaclass-的方法"><strong>2. 自定义 metaclass 的方法</strong></h5>
<pre tabindex="0"><code>class Singleton2(type):
    &quot;&quot;&quot;单例实现方式二&quot;&quot;&quot;

    def __init__(cls, what, bases=None, dict=None):
        super().__init__(what, bases, dict)
        cls._instance = None # 初始化全局变量cls._instance为None

    def __call__(cls, *args, **kwargs):
        # 控制对象的创建过程，如果cls._instance为None则创建，否则直接返回
        if cls._instance is None:
            cls._instance = super().__call__(*args, **kwargs)
        return cls._instance

class CustomClass(metaclass=Singleton2):
    &quot;&quot;&quot;用户自定义的类&quot;&quot;&quot;

    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

tony = CustomClass(&quot;Tony&quot;)
karry = CustomClass(&quot;Karry&quot;)
print(tony.getName(), karry.getName())
print(&quot;id(tony):&quot;, id(tony), &quot;id(karry):&quot;, id(karry))
print(&quot;tony == karry:&quot;, tony == karry)

</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>Tony Tony
id(tony): 50794608 id(karry): 50794608
tony == karry: True

</code></pre><p>在上面的代码中，我们定义了一个 metaclass（Singleton2）来控制对象的实例化过程。在定义自己的类时，我们通过 class CustomClass(metaclass=Singleton2) 来显示地指定 metaclass 为 Singleton2。如果你还不太熟悉 metaclass，想了解更多关于它的原理，请参见《[附录 Python 中 metaclass 的原理](》。</p>
<h5 id="3-装饰器的方法"><strong>3. 装饰器的方法</strong></h5>
<pre tabindex="0"><code>def singletonDecorator(cls, *args, **kwargs):
    &quot;&quot;&quot;定义一个单例装饰器&quot;&quot;&quot;
    instance = {}

    def wrapperSingleton(*args, **kwargs):
        if cls not in instance:
            instance[cls] = cls(*args, **kwargs)
        return instance[cls]

    return wrapperSingleton

@singletonDecorator
class Singleton3:
    &quot;&quot;&quot;使用单例装饰器修饰一个类&quot;&quot;&quot;

    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

tony = Singleton3(&quot;Tony&quot;)
karry = Singleton3(&quot;Karry&quot;)
print(tony.getName(), karry.getName())
print(&quot;id(tony):&quot;, id(tony), &quot;id(karry):&quot;, id(karry))
print(&quot;tony == karry:&quot;, tony == karry)

</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>Tony Tony
id(tony): 46206704 id(karry): 46206704
tony == karry: True

</code></pre><p>装饰器的实质就是对传进来的参数进行补充，可以在原有的类不做任何代码变动的前提下增加额外的功能，使用装饰器可以装饰多个类。用装饰器的方式来实现单例模式，通用性非常好，在实际项目中用的非常多。</p>
<h4 id="类图">类图</h4>
<p>上面的代码框架可用类图表示如下：</p>
<p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2028%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/assets/55e4e340-c394-11e8-b5ca-0da8fdb41124.jpg" alt="enter image description here"></p>
<h4 id="基于框架的实现">基于框架的实现</h4>
<p>通过上面的方式三，我们知道，定义通用的装饰器方法之后再用它去修饰一个类，这个类就成了一个单例类，使用起来非常方便。最开始的示例代码我们假设它为 version 1.0，那么再看看基于装饰器的 version 2.0 吧。</p>
<pre tabindex="0"><code>@singletonDecorator
class MyBeautifulGril(object):
    &quot;&quot;&quot;我的漂亮女神&quot;&quot;&quot;

    def __init__(self, name):
        self.__name = name
        if self.__name == name:
            print(&quot;遇见&quot; + name + &quot;，我一见钟情！&quot;)
        else:
            print(&quot;遇见&quot; + name + &quot;，我置若罔闻！&quot;)

    def showMyHeart(self):
        print(self.__name + &quot;就我心中的唯一！&quot;)

</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>遇见Jenny，我一见钟情！
Jenny就我心中的唯一！
Jenny就我心中的唯一！
id(jenny): 58920752  id(kimi): 58920752

</code></pre><h3 id="应用场景">应用场景</h3>
<ol>
<li>你希望这个类只有一个且只能有一个实例；</li>
<li>项目中的一些全局管理类（Manager）可以用单例来实现。</li>
</ol>

        </div>
    </article>
</div>

    </main>
    <footer>
        <div id="pagination">
            
<div class="paginator">
    <div class="prev">
        
        <a href="/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/03-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%BA%BA%E4%B8%8E%E6%B0%B4%E7%9A%84%E4%B8%89%E6%80%81/"><span>03 状态模式：人与水的三态</span></a>
    </div>
    <div class="next">
        
        <a href="/documents/columns/design/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F28%E8%AE%B2/05-%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F%E6%88%91%E7%9A%84%E5%81%87%E6%9D%A1%E5%8E%BB%E5%93%AA%E4%BA%86/"><span>05 职责模式：我的假条去哪了</span></a>
    </div>
</div>

        </div>
        <div id="copyright" style="display: none;">
    
    
    <p>&copy; 4040 <a href="/"></a>, powered by Hugo and Qiao</p>
</div>
    </footer>
    
</body>

</html>