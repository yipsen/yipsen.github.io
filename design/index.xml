<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Designs on Yipsen Ye</title>
    <link>http://localhost:8080/design/</link>
    <description>Recent content in Designs on Yipsen Ye</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 05 Mar 2022 08:34:41 +0000</lastBuildDate>
    <atom:link href="http://localhost:8080/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一致性哈希</title>
      <link>http://localhost:8080/design/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</link>
      <pubDate>Sat, 05 Mar 2022 08:34:41 +0000</pubDate>
      <guid>http://localhost:8080/design/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</guid>
      <description>&lt;p&gt;在容器化大行其道的当下，为满足服务横向扩容，对无状态服务一直是倍加推崇的，尽管如此，基于在性能效率上的考量，有状态服务仍有存在的空间，主要因其优点在于数据本地化后可以减少数据的网络交互，同时拥有更高的数据一致性（例如 Sticky Session），因此也多用于数据或网络强相关的服务上。&lt;/p&gt;&#xA;&lt;p&gt;如果系统设计上采用有状态的服务，那么不可避免的需要解决一个问题，即如何做到有状态服务在横向扩缩容时尽可能少的造成影响，一种常用的方案便是一致性哈希。&lt;/p&gt;&#xA;&lt;p&gt;一致性哈希算法早在&lt;a href=&#34;https://dl.acm.org/doi/10.1145/258533.258660&#34;&gt;https://dl.acm.org/doi/10.1145/258533.258660&lt;/a&gt;论文中提及，其在分布式缓存系统上有广泛的使用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;&#xA;&lt;p&gt;对于分布式系统，我们通常希望所有用户的信息与请求可以均匀地分配到各个节点上，以均摊压力，避免单点故障。即通常需要对服务做负载均衡策略。&lt;/p&gt;&#xA;&lt;p&gt;假设一个分布式缓存系统，用以存储用户相关的信息，服务总共部署了N个节点，在负载均衡策略上希望用户可以均匀的映射到部署的节点上，那么最容易想到采用通用的哈希方式，即通过计算用户ID的哈希值，再对节点总数进行取模后即可找到用户分布到的节点。由于哈希函数其散列以及稳定的特性，可以保证用户均匀地分布到服务所部署的节点上。&lt;/p&gt;&#xA;&lt;p&gt;当然在上述负载均衡方案中，如果节点能永久不变的运行，便完事大吉了。然而，当节点发生扩缩容导致总节点数发生变化时，将导致用户到节点的映射关系会彻底打乱。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;假设节点 N 宕机（即节点退出）时，原先映射到节点 N 的用户会受限丢失数据，且由于映射采用的哈希函数的逻辑不变（hashcode * n），原先分布到节点 N 的用户，下次存储仍然会被分配到节点 N，但实际节点 N 已宕机下线，因此这部分用户将一直无法使用，处于失效状态。而如果我们修正哈希函数，更改为（hashcode &amp;amp; (n - 1)），此时虽然失效用户可以重新映射到存活的节点上，但由于映射算法的变化，会导致原先的映射关系全部打乱。&lt;/li&gt;&#xA;&lt;li&gt;同样的，假设由于业务扩展，原先 N 个节点已不足支撑，需横向扩容节点数到（N + 1），由于原先映射关系的稳定性，如不更改映射函数，新增的节点不会有用户访问，而修改映射函数为&lt;code&gt;hashcode % (n + 1)&lt;/code&gt;则会遇到同上的场景，原先所有的映射关系全部失效，需重算，重算后关联的节点将不保证是原来的节点。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;而一致性哈希的目标正是解决在节点扩缩容时，尽可能的维持原先映射关系的不变，仅影响小部分用户。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本特性&#34;&gt;基本特性&lt;/h2&gt;&#xA;&lt;p&gt;我们养成解决问题的一贯方式，找出问题，针对问题提出目标，再围绕目标去思考方案去达成，从而解决问题。&lt;/p&gt;&#xA;&lt;p&gt;我们可以从上述说到的问题场景中总结出几个关键问题点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;服务节点扩缩容时，映射关系彻底打乱，发生大量的数据迁移。&lt;/li&gt;&#xA;&lt;li&gt;有新节点上线时，映射关系全部打乱，出现映射在健康节点的KEY又映射到另一个原健康节点上。出现无谓的迁移。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;针对这几个问题，我们可以提出几个关键特性要求。&lt;/p&gt;&#xA;&lt;h3 id=&#34;21-单调性&#34;&gt;2.1 单调性&lt;/h3&gt;&#xA;&lt;p&gt;当有新的节点上线后，系统中原有的 KEY 要么还是映射到原来的节点上，要么映射到新节点上，不会出现从一个老节点重新映射到其他老节点的情况。&lt;/p&gt;&#xA;&lt;h3 id=&#34;22-稳定性&#34;&gt;2.2 稳定性&lt;/h3&gt;&#xA;&lt;p&gt;当服务发生扩缩容时，发生迁移的数据量尽可能地少&lt;/p&gt;&#xA;&lt;h3 id=&#34;23-平衡性&#34;&gt;2.3 平衡性&lt;/h3&gt;&#xA;&lt;p&gt;不同的 KEY 通过算法映射后，可以比较均衡地分布在所有节点上。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一致性哈希&#34;&gt;一致性哈希&lt;/h2&gt;&#xA;&lt;p&gt;下面讲下一个常用的一致性哈希算法，也是所熟知的割环法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;哈希环&#34;&gt;哈希环&lt;/h3&gt;&#xA;&lt;p&gt;为满足我们提出的特性，我们试图分析原先的普通哈希映射方案，可以看到对象是生硬的映射到节点上的，随节点消失后，我们可以尝试把失去节点的迁移到原健康的节点，而尽量保持正常的对象不变化。为保证映射方式一致，我们可以把生硬的一步映射到节点上改为下面的方式。&lt;/p&gt;&#xA;&lt;p&gt;首先我们构建一个长度为&lt;code&gt;2^32&lt;/code&gt;大小的链表，并采用哈希函数，将对象映射到链表上：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../../images/Consistent-Hash-01.svg&#34; alt=&#34;Consistent Hash 01&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;之后再使用同样的方式，将节点也映射到链表上：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../../images/Consistent-Hash-02.svg&#34; alt=&#34;Consistent Hash 02&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来将对象与节点建立起映射关系，可以将对象像右寻找节点，找到的第一个节点便认为是该对象所分布的节点（如果对象与节点映射在链表上的位置重合，则也认为该节点为对象所分布的节点），以此建立起对应关系。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../../images/Consistent-Hash-02.svg&#34; alt=&#34;Consistent Hash 02&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>【持续更新】Web 前端设计规范汇总</title>
      <link>http://localhost:8080/design/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0web-%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sat, 05 Mar 2022 08:34:41 +0800</pubDate>
      <guid>http://localhost:8080/design/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0web-%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%B1%87%E6%80%BB/</guid>
      <description>&lt;h3 id=&#34;1-ios-human-interface-guideline----apple&#34;&gt;1. iOS Human Interface Guideline &amp;ndash; Apple&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/design/&#34;&gt;Design - Apple Develop&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-material-design----google&#34;&gt;2. Material Design &amp;ndash; Google&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://material.io/guidelines/&#34;&gt;Material Design&lt;/a&gt;&#xA;&lt;a href=&#34;https://material.io/components/&#34;&gt;Material Components&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.mdui.org/design/&#34;&gt;Material Design 中文文档、指南、翻译&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-fluent-design-system----microsoft&#34;&gt;3. Fluent Design System &amp;ndash; Microsoft&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://fluent.microsoft.com/&#34;&gt;Fluent Design System&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.microsoft.com/en-us/design/&#34;&gt;Microsoft Design&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-ibm-design-language----ibm&#34;&gt;4. IBM Design Language &amp;ndash; IBM&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/design/language/&#34;&gt;IBM Design Language&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-photon-design-system----firefox&#34;&gt;5. Photon Design System &amp;ndash; Firefox&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://design.firefox.com/photon/&#34;&gt;Photon Design System&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;6-yelp-styleguide----yelp&#34;&gt;6. Yelp Styleguide &amp;ndash; Yelp&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.yelp.com/styleguide/&#34;&gt;Styleguide&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;7-facebook-design----facebook&#34;&gt;7. Facebook Design &amp;ndash; Facebook&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://facebook.design/&#34;&gt;Facebook Design - What&amp;rsquo;s on our mind?&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;8-ant-design----蚂蚁金服阿里巴巴&#34;&gt;8. Ant Design &amp;ndash; 蚂蚁金服（阿里巴巴）&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://ant.design/index-cn/&#34;&gt;A UI Design Language&lt;/a&gt;&#xA;&lt;a href=&#34;https://mobile.ant.design/index-cn/&#34;&gt;A Mobile Design Specification&lt;/a&gt;&#xA;&lt;a href=&#34;https://motion.ant.design/&#34;&gt;Ant Motion - 一个 React 的动效设计解决方案&lt;/a&gt;&#xA;&lt;a href=&#34;https://fusion.design/&#34;&gt;Alibaba Fusion Design - 企业级的中后台设计系统解决方案&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>创建型 - 单例模式</title>
      <link>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</link>
      <pubDate>Sun, 06 Feb 2022 16:31:43 +0000</pubDate>
      <guid>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</guid>
      <description>&lt;p&gt;单例模式（Singleton Pattern）属于创建类型的一种常用的软件设计模式。&lt;/p&gt;&#xA;&lt;p&gt;单例对象保证全局（或指定上下文中，如进程，线程内唯一）仅有一个实例存在，并提供一个该唯一实例的访问点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要单例模式&#34;&gt;为什么需要单例模式&lt;/h2&gt;&#xA;&lt;p&gt;打井喝水，并不是每个人想喝水就要打一口井。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优点：在内存里只有一个实例，所以能够节约系统资源，减少了内存的开销，尤其是频繁的创建和销毁实例，可以提高系统效率，同时也能够严格控制客户对它的访问。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;缺点：也正是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，这样扩展起来有一定的困难。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;优点即缺点，所以更应该说是特点，在特定场景下使用。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;常见应用场景&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;spring bean&lt;/li&gt;&#xA;&lt;li&gt;数据库连接&lt;/li&gt;&#xA;&lt;li&gt;需要频繁的进行创建和销毁的对象&lt;/li&gt;&#xA;&lt;li&gt;创建对象时耗时过多或耗费资源过多(重量级对象)&lt;/li&gt;&#xA;&lt;li&gt;经常用到的对象、工具类对象、频繁访问数据库或文件的对象(数据源、session工厂)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;classDiagram&#xD;&#xA;    class Singleton {&#xD;&#xA;        -Singleton instance&#xD;&#xA;        -Singleton()&#xD;&#xA;        +static getInstance() Singleton&#xD;&#xA;    }&#xD;&#xA;    Singleton --o Singleton&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;&#xA;&lt;p&gt;要实现单例模式，关键有 3 个要素：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;单例类只有一个实例对象；如&lt;code&gt;instance&lt;/code&gt;；此为单例模式的核心要素。&lt;/li&gt;&#xA;&lt;li&gt;该单例对象必须由单例类自行创建；一般情况下会将构造函数声明为私有的，如&lt;code&gt;private Singleton()&lt;/code&gt;；这样外部无法实例化，也无法被继承，此举为保证唯一性，从而避免勿用。&lt;/li&gt;&#xA;&lt;li&gt;单例类对外提供一个访问该单例的全局访问点；如&lt;code&gt;getInstance()&lt;/code&gt;；由于已阻止外部构建，即单例类是一个只读类，外部不能创建或修改，需提供一个读取接口。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;即为了避免城市被私人挖得千疮百孔，没收公众的挖井工具，收归专门管理，但开放水利给公众使用。&lt;/p&gt;&#xA;&lt;p&gt;具体常用的几种实现方法：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-饿汉式&#34;&gt;1. 饿汉式&lt;/h3&gt;&#xA;&lt;p&gt;饿汉式顾名思义就是把食物（对象）提前做好，需要时直接拿取即可使用（吃掉）。简而言之即&lt;code&gt;预先构建&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 饿汉式单例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Eager&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 提前把对象实例化，此对象实例全局唯一&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Eager instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Eager();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 私有化构造器，不允许外部使用，以免破坏唯一性&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Eager&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;singleton have been created&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 提供唯一访问点&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Eager &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 功能特性&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;eatSomething&lt;/span&gt;(String something) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; something &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; eat&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 测试代码&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;testEager&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// TODO: make it multithread&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assertEquals(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cake eat&amp;#34;&lt;/span&gt;, Eager.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;eatSomething&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cake&amp;#34;&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;饿汉式是最省心的一种方案，其缺点就是占用资源，因为实例是提前创建的而不是按需，因此就算对象不被使用也会一直占据内存空间，其在启动时就需要耗时进行构建。&lt;/p&gt;</description>
    </item>
    <item>
      <title>结构型 - 代理模式</title>
      <link>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</link>
      <pubDate>Sun, 06 Feb 2022 16:31:43 +0000</pubDate>
      <guid>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</guid>
      <description>&lt;p&gt;代理在软件设计中是一种非常常见的设计思路，&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要代理模式&#34;&gt;为什么需要代理模式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;常见应用场景&#34;&gt;常见应用场景&lt;/h3&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;&#xA;&lt;p&gt;代理模式实现上有静态代理与动态代理之分。而动态代理又有JDK自带的实现方案，也有CGLib等第三方工具的实现方案，效果各有不同。&lt;/p&gt;&#xA;&lt;p&gt;一、静态代理&lt;/p&gt;&#xA;&lt;p&gt;二、动态代理（JDK实现方案）&lt;/p&gt;&#xA;&lt;p&gt;三、动态代理（CGLib实现方案）&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用案例&#34;&gt;使用案例&lt;/h2&gt;&#xA;&lt;p&gt;// 待补充实际工作上项目的使用案例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;引申&#34;&gt;引申&lt;/h2&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;</description>
    </item>
    <item>
      <title>行为型 - 观察者模式</title>
      <link>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</link>
      <pubDate>Sun, 06 Feb 2022 16:31:43 +0000</pubDate>
      <guid>http://localhost:8080/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8/</guid>
      <description>&lt;p&gt;观察者模式（Observer Pattern）属于行为类型的一种常用的软件设计模式。还有其他的称谓如，发布-订阅模式，模型-视图模式，而最常见的应用就是事件-通知机制了。&lt;/p&gt;&#xA;&lt;p&gt;该模式定义了一种一对多的依赖关系，并对关系进行解耦。即一个对象发生变化时，将通知所有依赖他的对象，以进一步处理相应变化。通过变化产生事件，进而通知处理相应变化的方式，实现了两个对象的解耦，并提供了灵活的依赖关系。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要观察者模式&#34;&gt;为什么需要观察者模式&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解耦&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;常见应用场景&#34;&gt;常见应用场景&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;spring event&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;classDiagram&#xD;&#xA;    class Subject {&#xD;&#xA;        &amp;lt;&amp;lt;abstract&amp;gt;&amp;gt;&#xD;&#xA;        +observers&#xD;&#xA;        +addObserver()&#xD;&#xA;        +removeObserver()&#xD;&#xA;        +notifyObserver()&#xD;&#xA;    }&#xD;&#xA;    class Observer {&#xD;&#xA;        &amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&#xD;&#xA;        update()&#xD;&#xA;    }&#xD;&#xA;    class ConcreteSubject {&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;    class ContreteObserver {&#xD;&#xA;&#xD;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;&#xA;&lt;p&gt;要实现观察者模式，其关键有 4 个对象，分别是：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;对象&lt;/th&gt;&#xA;          &lt;th&gt;称谓&lt;/th&gt;&#xA;          &lt;th&gt;特性&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Subject&lt;/td&gt;&#xA;          &lt;td&gt;被观察者&lt;/td&gt;&#xA;          &lt;td&gt;被观察者提供一系列方法以维护观察者列表（可随时进行增删），同时定义通知方法，以在发生变化时通知已维护在列表中的观察者们。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ConcreteSubject&lt;/td&gt;&#xA;          &lt;td&gt;具体的被观察者&lt;/td&gt;&#xA;          &lt;td&gt;被观察者的具体实现类，实现具体场景下发送变化通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Observer&lt;/td&gt;&#xA;          &lt;td&gt;观察者&lt;/td&gt;&#xA;          &lt;td&gt;观察者可以是一个或多个，当被观察者Subject发生变化时，观察者将收到通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ConcreteObserver&lt;/td&gt;&#xA;          &lt;td&gt;具体的观察者&lt;/td&gt;&#xA;          &lt;td&gt;观察者的具体实现类，不同的观察者在收到通知后可实现不同的操作。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;1-基础方式&#34;&gt;1. 基础方式&lt;/h3&gt;&#xA;&lt;p&gt;观察者模式实现如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;定义被观察者&lt;/p&gt;&#xA;&lt;p&gt;关键定义三个特性：添加观察者，移除观察者，通知观察者。其中通知观察者可由具体实现类按需在具体场景下处理发送逻辑。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Subject&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Observer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; observers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addObserver&lt;/span&gt;(Observer observer) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        observers.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(observer);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeObserver&lt;/span&gt;(Observer observer) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        observers.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(observer);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;notifyObserver&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;被观察者的具体实现类&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
